// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: topic.proto

package moment

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type TopicPageRep struct {
	Topics               []*Topic `protobuf:"bytes,1,rep,name=Topics,proto3" json:"Topics,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TopicPageRep) Reset()         { *m = TopicPageRep{} }
func (m *TopicPageRep) String() string { return proto.CompactTextString(m) }
func (*TopicPageRep) ProtoMessage()    {}
func (*TopicPageRep) Descriptor() ([]byte, []int) {
	return fileDescriptor_7312ad0e4fa171e8, []int{0}
}
func (m *TopicPageRep) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopicPageRep) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopicPageRep.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TopicPageRep) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopicPageRep.Merge(m, src)
}
func (m *TopicPageRep) XXX_Size() int {
	return m.Size()
}
func (m *TopicPageRep) XXX_DiscardUnknown() {
	xxx_messageInfo_TopicPageRep.DiscardUnknown(m)
}

var xxx_messageInfo_TopicPageRep proto.InternalMessageInfo

func (m *TopicPageRep) GetTopics() []*Topic {
	if m != nil {
		return m.Topics
	}
	return nil
}

type TopicTypeReq struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TopicTypeReq) Reset()         { *m = TopicTypeReq{} }
func (m *TopicTypeReq) String() string { return proto.CompactTextString(m) }
func (*TopicTypeReq) ProtoMessage()    {}
func (*TopicTypeReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_7312ad0e4fa171e8, []int{1}
}
func (m *TopicTypeReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopicTypeReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopicTypeReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TopicTypeReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopicTypeReq.Merge(m, src)
}
func (m *TopicTypeReq) XXX_Size() int {
	return m.Size()
}
func (m *TopicTypeReq) XXX_DiscardUnknown() {
	xxx_messageInfo_TopicTypeReq.DiscardUnknown(m)
}

var xxx_messageInfo_TopicTypeReq proto.InternalMessageInfo

type TopicTypeRep struct {
	TopicTypes           []*TopicType `protobuf:"bytes,1,rep,name=TopicTypes,proto3" json:"TopicTypes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *TopicTypeRep) Reset()         { *m = TopicTypeRep{} }
func (m *TopicTypeRep) String() string { return proto.CompactTextString(m) }
func (*TopicTypeRep) ProtoMessage()    {}
func (*TopicTypeRep) Descriptor() ([]byte, []int) {
	return fileDescriptor_7312ad0e4fa171e8, []int{2}
}
func (m *TopicTypeRep) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopicTypeRep) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopicTypeRep.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TopicTypeRep) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopicTypeRep.Merge(m, src)
}
func (m *TopicTypeRep) XXX_Size() int {
	return m.Size()
}
func (m *TopicTypeRep) XXX_DiscardUnknown() {
	xxx_messageInfo_TopicTypeRep.DiscardUnknown(m)
}

var xxx_messageInfo_TopicTypeRep proto.InternalMessageInfo

func (m *TopicTypeRep) GetTopicTypes() []*TopicType {
	if m != nil {
		return m.TopicTypes
	}
	return nil
}

type TopicPageReq struct {
	TopicTypeID          int64    `protobuf:"varint,1,opt,name=TopicTypeID,proto3" json:"TopicTypeID,omitempty"`
	TopicName            string   `protobuf:"bytes,2,opt,name=TopicName,proto3" json:"TopicName,omitempty"`
	TopicID              int64    `protobuf:"varint,3,opt,name=TopicID,proto3" json:"TopicID,omitempty"`
	Limit                int64    `protobuf:"varint,4,opt,name=Limit,proto3" json:"Limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TopicPageReq) Reset()         { *m = TopicPageReq{} }
func (m *TopicPageReq) String() string { return proto.CompactTextString(m) }
func (*TopicPageReq) ProtoMessage()    {}
func (*TopicPageReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_7312ad0e4fa171e8, []int{3}
}
func (m *TopicPageReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopicPageReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopicPageReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TopicPageReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopicPageReq.Merge(m, src)
}
func (m *TopicPageReq) XXX_Size() int {
	return m.Size()
}
func (m *TopicPageReq) XXX_DiscardUnknown() {
	xxx_messageInfo_TopicPageReq.DiscardUnknown(m)
}

var xxx_messageInfo_TopicPageReq proto.InternalMessageInfo

func (m *TopicPageReq) GetTopicTypeID() int64 {
	if m != nil {
		return m.TopicTypeID
	}
	return 0
}

func (m *TopicPageReq) GetTopicName() string {
	if m != nil {
		return m.TopicName
	}
	return ""
}

func (m *TopicPageReq) GetTopicID() int64 {
	if m != nil {
		return m.TopicID
	}
	return 0
}

func (m *TopicPageReq) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type Topic struct {
	// ID 主键
	// @inject_tag: db:"id"
	ID int64 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty" db:"id"`
	// TopicID ID
	// @inject_tag: db:"topic_id"
	TopicID int64 `protobuf:"varint,2,opt,name=TopicID,proto3" json:"TopicID,omitempty" db:"topic_id"`
	// TopicName 话题
	// @inject_tag: db:"topic_name" select:"like"
	TopicName string `protobuf:"bytes,3,opt,name=TopicName,proto3" json:"TopicName,omitempty" db:"topic_name" select:"like"`
	// TypeID 类型ID
	// @inject_tag: db:"type_id"
	TypeID int32 `protobuf:"varint,4,opt,name=TypeID,proto3" json:"TypeID,omitempty" db:"type_id"`
	// Tag 标签
	// @inject_tag: db:"tag"
	Tag int32 `protobuf:"varint,5,opt,name=Tag,proto3" json:"Tag,omitempty" db:"tag"`
	// Subtitle 副标题
	// @inject_tag: db:"subtitle"
	Subtitle string `protobuf:"bytes,6,opt,name=Subtitle,proto3" json:"Subtitle,omitempty" db:"subtitle"`
	// CreateAt 类型名称
	// @inject_tag: db:"create_at"
	CreateAt int64 `protobuf:"varint,7,opt,name=CreateAt,proto3" json:"CreateAt,omitempty" db:"create_at"`
	// CreateBy 创建人
	// @inject_tag: db:"create_by"
	CreateBy int32 `protobuf:"varint,8,opt,name=CreateBy,proto3" json:"CreateBy,omitempty" db:"create_by"`
	// Status 状态
	// @inject_tag: db:"status"
	Status               int32    `protobuf:"varint,9,opt,name=Status,proto3" json:"Status,omitempty" db:"status"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Topic) Reset()         { *m = Topic{} }
func (m *Topic) String() string { return proto.CompactTextString(m) }
func (*Topic) ProtoMessage()    {}
func (*Topic) Descriptor() ([]byte, []int) {
	return fileDescriptor_7312ad0e4fa171e8, []int{4}
}
func (m *Topic) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Topic) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Topic.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Topic) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Topic.Merge(m, src)
}
func (m *Topic) XXX_Size() int {
	return m.Size()
}
func (m *Topic) XXX_DiscardUnknown() {
	xxx_messageInfo_Topic.DiscardUnknown(m)
}

var xxx_messageInfo_Topic proto.InternalMessageInfo

func (m *Topic) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Topic) GetTopicID() int64 {
	if m != nil {
		return m.TopicID
	}
	return 0
}

func (m *Topic) GetTopicName() string {
	if m != nil {
		return m.TopicName
	}
	return ""
}

func (m *Topic) GetTypeID() int32 {
	if m != nil {
		return m.TypeID
	}
	return 0
}

func (m *Topic) GetTag() int32 {
	if m != nil {
		return m.Tag
	}
	return 0
}

func (m *Topic) GetSubtitle() string {
	if m != nil {
		return m.Subtitle
	}
	return ""
}

func (m *Topic) GetCreateAt() int64 {
	if m != nil {
		return m.CreateAt
	}
	return 0
}

func (m *Topic) GetCreateBy() int32 {
	if m != nil {
		return m.CreateBy
	}
	return 0
}

func (m *Topic) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

// TopicType ...
type TopicType struct {
	// ID 主键
	// @inject_tag: db:"id"
	ID int64 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty" db:"id"`
	// TopicTypeID ID
	// @inject_tag: db:"topic_type_id"
	TopicTypeID int64 `protobuf:"varint,2,opt,name=TopicTypeID,proto3" json:"TopicTypeID,omitempty" db:"topic_type_id"`
	// TopicTypeName 名称
	// @inject_tag: db:"topic_type_name"
	TopicTypeName string `protobuf:"bytes,3,opt,name=TopicTypeName,proto3" json:"TopicTypeName,omitempty" db:"topic_type_name"`
	// CreateAt 创建事件
	// @inject_tag: db:"create_at"
	CreateAt int64 `protobuf:"varint,4,opt,name=CreateAt,proto3" json:"CreateAt,omitempty" db:"create_at"`
	// CreateBy 创建人
	// @inject_tag: db:"create_by"
	CreateBy int32 `protobuf:"varint,5,opt,name=CreateBy,proto3" json:"CreateBy,omitempty" db:"create_by"`
	// Seq 排序
	// @inject_tag: db:"seq"
	Seq int32 `protobuf:"varint,6,opt,name=Seq,proto3" json:"Seq,omitempty" db:"seq"`
	// Status 状态
	// @inject_tag: db:"status"
	Status               int32    `protobuf:"varint,7,opt,name=Status,proto3" json:"Status,omitempty" db:"status"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TopicType) Reset()         { *m = TopicType{} }
func (m *TopicType) String() string { return proto.CompactTextString(m) }
func (*TopicType) ProtoMessage()    {}
func (*TopicType) Descriptor() ([]byte, []int) {
	return fileDescriptor_7312ad0e4fa171e8, []int{5}
}
func (m *TopicType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopicType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopicType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TopicType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopicType.Merge(m, src)
}
func (m *TopicType) XXX_Size() int {
	return m.Size()
}
func (m *TopicType) XXX_DiscardUnknown() {
	xxx_messageInfo_TopicType.DiscardUnknown(m)
}

var xxx_messageInfo_TopicType proto.InternalMessageInfo

func (m *TopicType) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *TopicType) GetTopicTypeID() int64 {
	if m != nil {
		return m.TopicTypeID
	}
	return 0
}

func (m *TopicType) GetTopicTypeName() string {
	if m != nil {
		return m.TopicTypeName
	}
	return ""
}

func (m *TopicType) GetCreateAt() int64 {
	if m != nil {
		return m.CreateAt
	}
	return 0
}

func (m *TopicType) GetCreateBy() int32 {
	if m != nil {
		return m.CreateBy
	}
	return 0
}

func (m *TopicType) GetSeq() int32 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *TopicType) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func init() {
	proto.RegisterType((*TopicPageRep)(nil), "moment.TopicPageRep")
	proto.RegisterType((*TopicTypeReq)(nil), "moment.TopicTypeReq")
	proto.RegisterType((*TopicTypeRep)(nil), "moment.TopicTypeRep")
	proto.RegisterType((*TopicPageReq)(nil), "moment.TopicPageReq")
	proto.RegisterType((*Topic)(nil), "moment.Topic")
	proto.RegisterType((*TopicType)(nil), "moment.TopicType")
}

func init() { proto.RegisterFile("topic.proto", fileDescriptor_7312ad0e4fa171e8) }

var fileDescriptor_7312ad0e4fa171e8 = []byte{
	// 419 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x93, 0xd1, 0xaa, 0xda, 0x40,
	0x10, 0x86, 0xdd, 0xc4, 0xc4, 0xe3, 0x78, 0x14, 0xbb, 0x48, 0x59, 0x42, 0x91, 0xb0, 0x54, 0xc8,
	0x95, 0x50, 0x5b, 0x1f, 0x40, 0x9b, 0x1b, 0xa1, 0x94, 0x92, 0xf8, 0x02, 0x51, 0x17, 0x09, 0x98,
	0x26, 0xea, 0x5a, 0xf0, 0xa6, 0x6f, 0x57, 0xe8, 0x55, 0xe9, 0x23, 0x14, 0xa1, 0xef, 0x51, 0x76,
	0x12, 0x63, 0x36, 0x4a, 0xcf, 0xdd, 0x7e, 0xff, 0xcc, 0xce, 0xfc, 0xb3, 0xcc, 0x42, 0x47, 0xa6,
	0x59, 0xbc, 0x1e, 0x67, 0x87, 0x54, 0xa6, 0xd4, 0x4e, 0xd2, 0x44, 0x7c, 0x95, 0x7c, 0x0a, 0xcf,
	0x4b, 0x25, 0x7f, 0x89, 0xb6, 0x22, 0x10, 0x19, 0x1d, 0x81, 0x8d, 0x7c, 0x64, 0xc4, 0x35, 0xbd,
	0xce, 0xa4, 0x3b, 0xce, 0x13, 0xc7, 0xa8, 0x06, 0x45, 0x90, 0xf7, 0x8a, 0x6b, 0xcb, 0x73, 0x26,
	0x02, 0xb1, 0xe7, 0x33, 0x8d, 0x33, 0xfa, 0x0e, 0xa0, 0xe4, 0x6b, 0xa9, 0x57, 0x5a, 0x29, 0xcc,
	0xac, 0x24, 0xf1, 0xef, 0x9a, 0x93, 0x3d, 0x75, 0xa1, 0x53, 0x46, 0x17, 0x3e, 0x23, 0x2e, 0xf1,
	0xcc, 0xa0, 0x2a, 0xd1, 0x37, 0xd0, 0x46, 0xfc, 0x1c, 0x25, 0x82, 0x19, 0x2e, 0xf1, 0xda, 0xc1,
	0x4d, 0xa0, 0x0c, 0x5a, 0x08, 0x0b, 0x9f, 0x99, 0x78, 0xf7, 0x8a, 0x74, 0x00, 0xd6, 0xa7, 0x38,
	0x89, 0x25, 0x6b, 0xa2, 0x9e, 0x03, 0xff, 0x4b, 0xc0, 0xc2, 0x0c, 0xda, 0x03, 0xa3, 0x6c, 0x68,
	0x2c, 0xfc, 0x6a, 0x25, 0x43, 0xaf, 0xa4, 0x39, 0x30, 0xeb, 0x0e, 0x5e, 0x83, 0x5d, 0x98, 0x57,
	0x8d, 0xac, 0xa0, 0x20, 0xda, 0x07, 0x73, 0x19, 0x6d, 0x99, 0x85, 0xa2, 0x3a, 0x52, 0x07, 0x9e,
	0xc2, 0xd3, 0x4a, 0xc6, 0x72, 0x27, 0x98, 0x8d, 0x65, 0x4a, 0x56, 0xb1, 0x8f, 0x07, 0x11, 0x49,
	0x31, 0x93, 0xac, 0x85, 0xed, 0x4b, 0xbe, 0xc5, 0xe6, 0x67, 0xf6, 0x84, 0xe5, 0x4a, 0x56, 0xdd,
	0x43, 0x19, 0xc9, 0xd3, 0x91, 0xb5, 0xf3, 0xee, 0x39, 0xf1, 0x1f, 0xa4, 0x30, 0xad, 0xdc, 0xdc,
	0xcd, 0x5a, 0x7b, 0x75, 0xe3, 0xfe, 0xd5, 0xdf, 0x42, 0xb7, 0xc4, 0xca, 0xdc, 0xba, 0xa8, 0xb9,
	0x6e, 0xfe, 0xc7, 0xb5, 0x55, 0x73, 0xdd, 0x07, 0x33, 0x14, 0x7b, 0x7c, 0x04, 0x2b, 0x50, 0xc7,
	0xca, 0x1c, 0xad, 0xea, 0x1c, 0x93, 0x5f, 0x04, 0x7a, 0xd8, 0xd3, 0x9f, 0x87, 0xe2, 0xf0, 0x2d,
	0x5e, 0x0b, 0x3a, 0x02, 0x73, 0xb6, 0xd9, 0x50, 0x7d, 0x67, 0x1d, 0x1d, 0x79, 0x83, 0x7a, 0x60,
	0xfb, 0x62, 0x27, 0xa4, 0x78, 0x31, 0xf3, 0x03, 0x34, 0xd5, 0x3a, 0xd2, 0x81, 0x16, 0x28, 0x36,
	0xd4, 0x79, 0xa4, 0x66, 0xbc, 0x41, 0xa7, 0x60, 0xe1, 0x4a, 0xd7, 0xae, 0x15, 0x7f, 0xc5, 0x79,
	0xa4, 0x66, 0xbc, 0x31, 0x7f, 0xfe, 0x79, 0x19, 0x92, 0xdf, 0x97, 0x21, 0xf9, 0x73, 0x19, 0x92,
	0x95, 0x8d, 0xff, 0xf4, 0xfd, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x8c, 0x57, 0x1b, 0x6f, 0xb6,
	0x03, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// TopicDBServiceClient is the client API for TopicDBService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TopicDBServiceClient interface {
	Add(ctx context.Context, in *Topic, opts ...grpc.CallOption) (*Topic, error)
	Delete(ctx context.Context, in *Topic, opts ...grpc.CallOption) (*Topic, error)
	Page(ctx context.Context, in *TopicPageReq, opts ...grpc.CallOption) (*TopicPageRep, error)
	Types(ctx context.Context, in *TopicTypeReq, opts ...grpc.CallOption) (*TopicTypeRep, error)
}

type topicDBServiceClient struct {
	cc *grpc.ClientConn
}

func NewTopicDBServiceClient(cc *grpc.ClientConn) TopicDBServiceClient {
	return &topicDBServiceClient{cc}
}

func (c *topicDBServiceClient) Add(ctx context.Context, in *Topic, opts ...grpc.CallOption) (*Topic, error) {
	out := new(Topic)
	err := c.cc.Invoke(ctx, "/moment.TopicDBService/Add", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topicDBServiceClient) Delete(ctx context.Context, in *Topic, opts ...grpc.CallOption) (*Topic, error) {
	out := new(Topic)
	err := c.cc.Invoke(ctx, "/moment.TopicDBService/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topicDBServiceClient) Page(ctx context.Context, in *TopicPageReq, opts ...grpc.CallOption) (*TopicPageRep, error) {
	out := new(TopicPageRep)
	err := c.cc.Invoke(ctx, "/moment.TopicDBService/Page", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topicDBServiceClient) Types(ctx context.Context, in *TopicTypeReq, opts ...grpc.CallOption) (*TopicTypeRep, error) {
	out := new(TopicTypeRep)
	err := c.cc.Invoke(ctx, "/moment.TopicDBService/Types", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TopicDBServiceServer is the server API for TopicDBService service.
type TopicDBServiceServer interface {
	Add(context.Context, *Topic) (*Topic, error)
	Delete(context.Context, *Topic) (*Topic, error)
	Page(context.Context, *TopicPageReq) (*TopicPageRep, error)
	Types(context.Context, *TopicTypeReq) (*TopicTypeRep, error)
}

// UnimplementedTopicDBServiceServer can be embedded to have forward compatible implementations.
type UnimplementedTopicDBServiceServer struct {
}

func (*UnimplementedTopicDBServiceServer) Add(ctx context.Context, req *Topic) (*Topic, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Add not implemented")
}
func (*UnimplementedTopicDBServiceServer) Delete(ctx context.Context, req *Topic) (*Topic, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (*UnimplementedTopicDBServiceServer) Page(ctx context.Context, req *TopicPageReq) (*TopicPageRep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Page not implemented")
}
func (*UnimplementedTopicDBServiceServer) Types(ctx context.Context, req *TopicTypeReq) (*TopicTypeRep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Types not implemented")
}

func RegisterTopicDBServiceServer(s *grpc.Server, srv TopicDBServiceServer) {
	s.RegisterService(&_TopicDBService_serviceDesc, srv)
}

func _TopicDBService_Add_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Topic)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicDBServiceServer).Add(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.TopicDBService/Add",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicDBServiceServer).Add(ctx, req.(*Topic))
	}
	return interceptor(ctx, in, info, handler)
}

func _TopicDBService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Topic)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicDBServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.TopicDBService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicDBServiceServer).Delete(ctx, req.(*Topic))
	}
	return interceptor(ctx, in, info, handler)
}

func _TopicDBService_Page_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TopicPageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicDBServiceServer).Page(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.TopicDBService/Page",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicDBServiceServer).Page(ctx, req.(*TopicPageReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TopicDBService_Types_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TopicTypeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicDBServiceServer).Types(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.TopicDBService/Types",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicDBServiceServer).Types(ctx, req.(*TopicTypeReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _TopicDBService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "moment.TopicDBService",
	HandlerType: (*TopicDBServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Add",
			Handler:    _TopicDBService_Add_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _TopicDBService_Delete_Handler,
		},
		{
			MethodName: "Page",
			Handler:    _TopicDBService_Page_Handler,
		},
		{
			MethodName: "Types",
			Handler:    _TopicDBService_Types_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "topic.proto",
}

func (m *TopicPageRep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopicPageRep) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TopicPageRep) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Topics) > 0 {
		for iNdEx := len(m.Topics) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Topics[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTopic(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TopicTypeReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopicTypeReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TopicTypeReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *TopicTypeRep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopicTypeRep) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TopicTypeRep) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TopicTypes) > 0 {
		for iNdEx := len(m.TopicTypes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TopicTypes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTopic(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TopicPageReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopicPageReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TopicPageReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Limit != 0 {
		i = encodeVarintTopic(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x20
	}
	if m.TopicID != 0 {
		i = encodeVarintTopic(dAtA, i, uint64(m.TopicID))
		i--
		dAtA[i] = 0x18
	}
	if len(m.TopicName) > 0 {
		i -= len(m.TopicName)
		copy(dAtA[i:], m.TopicName)
		i = encodeVarintTopic(dAtA, i, uint64(len(m.TopicName)))
		i--
		dAtA[i] = 0x12
	}
	if m.TopicTypeID != 0 {
		i = encodeVarintTopic(dAtA, i, uint64(m.TopicTypeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Topic) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Topic) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Topic) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != 0 {
		i = encodeVarintTopic(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x48
	}
	if m.CreateBy != 0 {
		i = encodeVarintTopic(dAtA, i, uint64(m.CreateBy))
		i--
		dAtA[i] = 0x40
	}
	if m.CreateAt != 0 {
		i = encodeVarintTopic(dAtA, i, uint64(m.CreateAt))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Subtitle) > 0 {
		i -= len(m.Subtitle)
		copy(dAtA[i:], m.Subtitle)
		i = encodeVarintTopic(dAtA, i, uint64(len(m.Subtitle)))
		i--
		dAtA[i] = 0x32
	}
	if m.Tag != 0 {
		i = encodeVarintTopic(dAtA, i, uint64(m.Tag))
		i--
		dAtA[i] = 0x28
	}
	if m.TypeID != 0 {
		i = encodeVarintTopic(dAtA, i, uint64(m.TypeID))
		i--
		dAtA[i] = 0x20
	}
	if len(m.TopicName) > 0 {
		i -= len(m.TopicName)
		copy(dAtA[i:], m.TopicName)
		i = encodeVarintTopic(dAtA, i, uint64(len(m.TopicName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.TopicID != 0 {
		i = encodeVarintTopic(dAtA, i, uint64(m.TopicID))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintTopic(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TopicType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopicType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TopicType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != 0 {
		i = encodeVarintTopic(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x38
	}
	if m.Seq != 0 {
		i = encodeVarintTopic(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x30
	}
	if m.CreateBy != 0 {
		i = encodeVarintTopic(dAtA, i, uint64(m.CreateBy))
		i--
		dAtA[i] = 0x28
	}
	if m.CreateAt != 0 {
		i = encodeVarintTopic(dAtA, i, uint64(m.CreateAt))
		i--
		dAtA[i] = 0x20
	}
	if len(m.TopicTypeName) > 0 {
		i -= len(m.TopicTypeName)
		copy(dAtA[i:], m.TopicTypeName)
		i = encodeVarintTopic(dAtA, i, uint64(len(m.TopicTypeName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.TopicTypeID != 0 {
		i = encodeVarintTopic(dAtA, i, uint64(m.TopicTypeID))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintTopic(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTopic(dAtA []byte, offset int, v uint64) int {
	offset -= sovTopic(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TopicPageRep) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Topics) > 0 {
		for _, e := range m.Topics {
			l = e.Size()
			n += 1 + l + sovTopic(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TopicTypeReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TopicTypeRep) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TopicTypes) > 0 {
		for _, e := range m.TopicTypes {
			l = e.Size()
			n += 1 + l + sovTopic(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TopicPageReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicTypeID != 0 {
		n += 1 + sovTopic(uint64(m.TopicTypeID))
	}
	l = len(m.TopicName)
	if l > 0 {
		n += 1 + l + sovTopic(uint64(l))
	}
	if m.TopicID != 0 {
		n += 1 + sovTopic(uint64(m.TopicID))
	}
	if m.Limit != 0 {
		n += 1 + sovTopic(uint64(m.Limit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Topic) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovTopic(uint64(m.ID))
	}
	if m.TopicID != 0 {
		n += 1 + sovTopic(uint64(m.TopicID))
	}
	l = len(m.TopicName)
	if l > 0 {
		n += 1 + l + sovTopic(uint64(l))
	}
	if m.TypeID != 0 {
		n += 1 + sovTopic(uint64(m.TypeID))
	}
	if m.Tag != 0 {
		n += 1 + sovTopic(uint64(m.Tag))
	}
	l = len(m.Subtitle)
	if l > 0 {
		n += 1 + l + sovTopic(uint64(l))
	}
	if m.CreateAt != 0 {
		n += 1 + sovTopic(uint64(m.CreateAt))
	}
	if m.CreateBy != 0 {
		n += 1 + sovTopic(uint64(m.CreateBy))
	}
	if m.Status != 0 {
		n += 1 + sovTopic(uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TopicType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovTopic(uint64(m.ID))
	}
	if m.TopicTypeID != 0 {
		n += 1 + sovTopic(uint64(m.TopicTypeID))
	}
	l = len(m.TopicTypeName)
	if l > 0 {
		n += 1 + l + sovTopic(uint64(l))
	}
	if m.CreateAt != 0 {
		n += 1 + sovTopic(uint64(m.CreateAt))
	}
	if m.CreateBy != 0 {
		n += 1 + sovTopic(uint64(m.CreateBy))
	}
	if m.Seq != 0 {
		n += 1 + sovTopic(uint64(m.Seq))
	}
	if m.Status != 0 {
		n += 1 + sovTopic(uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovTopic(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTopic(x uint64) (n int) {
	return sovTopic(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TopicPageRep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopicPageRep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopicPageRep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTopic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTopic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topics = append(m.Topics, &Topic{})
			if err := m.Topics[len(m.Topics)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTopic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTopic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTopic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopicTypeReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopicTypeReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopicTypeReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTopic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTopic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTopic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopicTypeRep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopicTypeRep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopicTypeRep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicTypes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTopic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTopic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TopicTypes = append(m.TopicTypes, &TopicType{})
			if err := m.TopicTypes[len(m.TopicTypes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTopic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTopic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTopic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopicPageReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopicPageReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopicPageReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicTypeID", wireType)
			}
			m.TopicTypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicTypeID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTopic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TopicName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			m.TopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTopic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTopic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTopic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Topic) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Topic: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Topic: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			m.TopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTopic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TopicName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeID", wireType)
			}
			m.TypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subtitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTopic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subtitle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateBy", wireType)
			}
			m.CreateBy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateBy |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTopic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTopic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTopic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopicType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopicType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopicType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicTypeID", wireType)
			}
			m.TopicTypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicTypeID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicTypeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopic
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTopic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TopicTypeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateBy", wireType)
			}
			m.CreateBy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateBy |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTopic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTopic
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTopic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTopic(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTopic
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTopic
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTopic
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTopic
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTopic
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTopic
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTopic        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTopic          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTopic = fmt.Errorf("proto: unexpected end of group")
)
