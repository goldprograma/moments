// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: base.proto

package moment

import (
	context "context"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"
	"gitlab.moments.im/pkg/protoc/imapigateway"

	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type UserIgnoresAllResp struct {
	UserIDs              []int32  `protobuf:"varint,1,rep,packed,name=UserIDs,proto3" json:"UserIDs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserIgnoresAllResp) Reset()         { *m = UserIgnoresAllResp{} }
func (m *UserIgnoresAllResp) String() string { return proto.CompactTextString(m) }
func (*UserIgnoresAllResp) ProtoMessage()    {}
func (*UserIgnoresAllResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{0}
}
func (m *UserIgnoresAllResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserIgnoresAllResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserIgnoresAllResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserIgnoresAllResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserIgnoresAllResp.Merge(m, src)
}
func (m *UserIgnoresAllResp) XXX_Size() int {
	return m.Size()
}
func (m *UserIgnoresAllResp) XXX_DiscardUnknown() {
	xxx_messageInfo_UserIgnoresAllResp.DiscardUnknown(m)
}

var xxx_messageInfo_UserIgnoresAllResp proto.InternalMessageInfo

func (m *UserIgnoresAllResp) GetUserIDs() []int32 {
	if m != nil {
		return m.UserIDs
	}
	return nil
}

type UserIgnoreMeGetResp struct {
	UserIDs              []int32  `protobuf:"varint,1,rep,packed,name=UserIDs,proto3" json:"UserIDs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserIgnoreMeGetResp) Reset()         { *m = UserIgnoreMeGetResp{} }
func (m *UserIgnoreMeGetResp) String() string { return proto.CompactTextString(m) }
func (*UserIgnoreMeGetResp) ProtoMessage()    {}
func (*UserIgnoreMeGetResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{1}
}
func (m *UserIgnoreMeGetResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserIgnoreMeGetResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserIgnoreMeGetResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserIgnoreMeGetResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserIgnoreMeGetResp.Merge(m, src)
}
func (m *UserIgnoreMeGetResp) XXX_Size() int {
	return m.Size()
}
func (m *UserIgnoreMeGetResp) XXX_DiscardUnknown() {
	xxx_messageInfo_UserIgnoreMeGetResp.DiscardUnknown(m)
}

var xxx_messageInfo_UserIgnoreMeGetResp proto.InternalMessageInfo

func (m *UserIgnoreMeGetResp) GetUserIDs() []int32 {
	if m != nil {
		return m.UserIDs
	}
	return nil
}

type UserContactsSyncReq struct {
	Action               int32    `protobuf:"varint,1,opt,name=Action,proto3" json:"Action,omitempty"`
	UserID               int32    `protobuf:"varint,2,opt,name=UserID,proto3" json:"UserID,omitempty"`
	ContactID            []int32  `protobuf:"varint,3,rep,packed,name=ContactID,proto3" json:"ContactID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserContactsSyncReq) Reset()         { *m = UserContactsSyncReq{} }
func (m *UserContactsSyncReq) String() string { return proto.CompactTextString(m) }
func (*UserContactsSyncReq) ProtoMessage()    {}
func (*UserContactsSyncReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{2}
}
func (m *UserContactsSyncReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserContactsSyncReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserContactsSyncReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserContactsSyncReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserContactsSyncReq.Merge(m, src)
}
func (m *UserContactsSyncReq) XXX_Size() int {
	return m.Size()
}
func (m *UserContactsSyncReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UserContactsSyncReq.DiscardUnknown(m)
}

var xxx_messageInfo_UserContactsSyncReq proto.InternalMessageInfo

func (m *UserContactsSyncReq) GetAction() int32 {
	if m != nil {
		return m.Action
	}
	return 0
}

func (m *UserContactsSyncReq) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *UserContactsSyncReq) GetContactID() []int32 {
	if m != nil {
		return m.ContactID
	}
	return nil
}

type UserContactsSyncRep struct {
	Code                 int32    `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Msg                  string   `protobuf:"bytes,2,opt,name=Msg,proto3" json:"Msg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserContactsSyncRep) Reset()         { *m = UserContactsSyncRep{} }
func (m *UserContactsSyncRep) String() string { return proto.CompactTextString(m) }
func (*UserContactsSyncRep) ProtoMessage()    {}
func (*UserContactsSyncRep) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{3}
}
func (m *UserContactsSyncRep) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserContactsSyncRep) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserContactsSyncRep.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserContactsSyncRep) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserContactsSyncRep.Merge(m, src)
}
func (m *UserContactsSyncRep) XXX_Size() int {
	return m.Size()
}
func (m *UserContactsSyncRep) XXX_DiscardUnknown() {
	xxx_messageInfo_UserContactsSyncRep.DiscardUnknown(m)
}

var xxx_messageInfo_UserContactsSyncRep proto.InternalMessageInfo

func (m *UserContactsSyncRep) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *UserContactsSyncRep) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

type UserAlbumsReq struct {
	UserID               int32    `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	FriendID             int32    `protobuf:"varint,2,opt,name=FriendID,proto3" json:"FriendID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserAlbumsReq) Reset()         { *m = UserAlbumsReq{} }
func (m *UserAlbumsReq) String() string { return proto.CompactTextString(m) }
func (*UserAlbumsReq) ProtoMessage()    {}
func (*UserAlbumsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{4}
}
func (m *UserAlbumsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserAlbumsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserAlbumsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserAlbumsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserAlbumsReq.Merge(m, src)
}
func (m *UserAlbumsReq) XXX_Size() int {
	return m.Size()
}
func (m *UserAlbumsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UserAlbumsReq.DiscardUnknown(m)
}

var xxx_messageInfo_UserAlbumsReq proto.InternalMessageInfo

func (m *UserAlbumsReq) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *UserAlbumsReq) GetFriendID() int32 {
	if m != nil {
		return m.FriendID
	}
	return 0
}

type UserAlbumsRep struct {
	Code                 int32    `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Msg                  string   `protobuf:"bytes,2,opt,name=Msg,proto3" json:"Msg,omitempty"`
	Medias               []*Media `protobuf:"bytes,3,rep,name=Medias,proto3" json:"Medias,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserAlbumsRep) Reset()         { *m = UserAlbumsRep{} }
func (m *UserAlbumsRep) String() string { return proto.CompactTextString(m) }
func (*UserAlbumsRep) ProtoMessage()    {}
func (*UserAlbumsRep) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{5}
}
func (m *UserAlbumsRep) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserAlbumsRep) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserAlbumsRep.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserAlbumsRep) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserAlbumsRep.Merge(m, src)
}
func (m *UserAlbumsRep) XXX_Size() int {
	return m.Size()
}
func (m *UserAlbumsRep) XXX_DiscardUnknown() {
	xxx_messageInfo_UserAlbumsRep.DiscardUnknown(m)
}

var xxx_messageInfo_UserAlbumsRep proto.InternalMessageInfo

func (m *UserAlbumsRep) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *UserAlbumsRep) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *UserAlbumsRep) GetMedias() []*Media {
	if m != nil {
		return m.Medias
	}
	return nil
}

type UserVersionGetRep struct {
	RecommendState       bool     `protobuf:"varint,1,opt,name=RecommendState,proto3" json:"RecommendState,omitempty"`
	RecommendUID         int32    `protobuf:"varint,2,opt,name=RecommendUID,proto3" json:"RecommendUID,omitempty"`
	FriendState          bool     `protobuf:"varint,3,opt,name=FriendState,proto3" json:"FriendState,omitempty"`
	FriendUID            int32    `protobuf:"varint,4,opt,name=FriendUID,proto3" json:"FriendUID,omitempty"`
	FollowState          bool     `protobuf:"varint,5,opt,name=FollowState,proto3" json:"FollowState,omitempty"`
	FollowUID            int32    `protobuf:"varint,6,opt,name=FollowUID,proto3" json:"FollowUID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserVersionGetRep) Reset()         { *m = UserVersionGetRep{} }
func (m *UserVersionGetRep) String() string { return proto.CompactTextString(m) }
func (*UserVersionGetRep) ProtoMessage()    {}
func (*UserVersionGetRep) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{6}
}
func (m *UserVersionGetRep) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserVersionGetRep) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserVersionGetRep.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserVersionGetRep) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserVersionGetRep.Merge(m, src)
}
func (m *UserVersionGetRep) XXX_Size() int {
	return m.Size()
}
func (m *UserVersionGetRep) XXX_DiscardUnknown() {
	xxx_messageInfo_UserVersionGetRep.DiscardUnknown(m)
}

var xxx_messageInfo_UserVersionGetRep proto.InternalMessageInfo

func (m *UserVersionGetRep) GetRecommendState() bool {
	if m != nil {
		return m.RecommendState
	}
	return false
}

func (m *UserVersionGetRep) GetRecommendUID() int32 {
	if m != nil {
		return m.RecommendUID
	}
	return 0
}

func (m *UserVersionGetRep) GetFriendState() bool {
	if m != nil {
		return m.FriendState
	}
	return false
}

func (m *UserVersionGetRep) GetFriendUID() int32 {
	if m != nil {
		return m.FriendUID
	}
	return 0
}

func (m *UserVersionGetRep) GetFollowState() bool {
	if m != nil {
		return m.FollowState
	}
	return false
}

func (m *UserVersionGetRep) GetFollowUID() int32 {
	if m != nil {
		return m.FollowUID
	}
	return 0
}

type UserVersionUpdateReq struct {
	UserID               int32    `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	IsRecommedUser       bool     `protobuf:"varint,2,opt,name=IsRecommedUser,proto3" json:"IsRecommedUser,omitempty"`
	Version              int64    `protobuf:"varint,3,opt,name=Version,proto3" json:"Version,omitempty"`
	Friend               []int32  `protobuf:"varint,4,rep,packed,name=Friend,proto3" json:"Friend,omitempty"`
	Fans                 []int32  `protobuf:"varint,5,rep,packed,name=Fans,proto3" json:"Fans,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserVersionUpdateReq) Reset()         { *m = UserVersionUpdateReq{} }
func (m *UserVersionUpdateReq) String() string { return proto.CompactTextString(m) }
func (*UserVersionUpdateReq) ProtoMessage()    {}
func (*UserVersionUpdateReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{7}
}
func (m *UserVersionUpdateReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserVersionUpdateReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserVersionUpdateReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserVersionUpdateReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserVersionUpdateReq.Merge(m, src)
}
func (m *UserVersionUpdateReq) XXX_Size() int {
	return m.Size()
}
func (m *UserVersionUpdateReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UserVersionUpdateReq.DiscardUnknown(m)
}

var xxx_messageInfo_UserVersionUpdateReq proto.InternalMessageInfo

func (m *UserVersionUpdateReq) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *UserVersionUpdateReq) GetIsRecommedUser() bool {
	if m != nil {
		return m.IsRecommedUser
	}
	return false
}

func (m *UserVersionUpdateReq) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *UserVersionUpdateReq) GetFriend() []int32 {
	if m != nil {
		return m.Friend
	}
	return nil
}

func (m *UserVersionUpdateReq) GetFans() []int32 {
	if m != nil {
		return m.Fans
	}
	return nil
}

type UserVersionUpdateRep struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserVersionUpdateRep) Reset()         { *m = UserVersionUpdateRep{} }
func (m *UserVersionUpdateRep) String() string { return proto.CompactTextString(m) }
func (*UserVersionUpdateRep) ProtoMessage()    {}
func (*UserVersionUpdateRep) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{8}
}
func (m *UserVersionUpdateRep) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserVersionUpdateRep) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserVersionUpdateRep.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserVersionUpdateRep) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserVersionUpdateRep.Merge(m, src)
}
func (m *UserVersionUpdateRep) XXX_Size() int {
	return m.Size()
}
func (m *UserVersionUpdateRep) XXX_DiscardUnknown() {
	xxx_messageInfo_UserVersionUpdateRep.DiscardUnknown(m)
}

var xxx_messageInfo_UserVersionUpdateRep proto.InternalMessageInfo

type UserAllIDReq struct {
	ExcludeUID           []int32  `protobuf:"varint,1,rep,packed,name=ExcludeUID,proto3" json:"ExcludeUID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserAllIDReq) Reset()         { *m = UserAllIDReq{} }
func (m *UserAllIDReq) String() string { return proto.CompactTextString(m) }
func (*UserAllIDReq) ProtoMessage()    {}
func (*UserAllIDReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{9}
}
func (m *UserAllIDReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserAllIDReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserAllIDReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserAllIDReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserAllIDReq.Merge(m, src)
}
func (m *UserAllIDReq) XXX_Size() int {
	return m.Size()
}
func (m *UserAllIDReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UserAllIDReq.DiscardUnknown(m)
}

var xxx_messageInfo_UserAllIDReq proto.InternalMessageInfo

func (m *UserAllIDReq) GetExcludeUID() []int32 {
	if m != nil {
		return m.ExcludeUID
	}
	return nil
}

type UserAllIDRep struct {
	UserIDs              []int32  `protobuf:"varint,1,rep,packed,name=UserIDs,proto3" json:"UserIDs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserAllIDRep) Reset()         { *m = UserAllIDRep{} }
func (m *UserAllIDRep) String() string { return proto.CompactTextString(m) }
func (*UserAllIDRep) ProtoMessage()    {}
func (*UserAllIDRep) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{10}
}
func (m *UserAllIDRep) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserAllIDRep) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserAllIDRep.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserAllIDRep) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserAllIDRep.Merge(m, src)
}
func (m *UserAllIDRep) XXX_Size() int {
	return m.Size()
}
func (m *UserAllIDRep) XXX_DiscardUnknown() {
	xxx_messageInfo_UserAllIDRep.DiscardUnknown(m)
}

var xxx_messageInfo_UserAllIDRep proto.InternalMessageInfo

func (m *UserAllIDRep) GetUserIDs() []int32 {
	if m != nil {
		return m.UserIDs
	}
	return nil
}

type UserRecommendCheckRep struct {
	Status               bool     `protobuf:"varint,1,opt,name=Status,proto3" json:"Status,omitempty"`
	LimitVIP             int32    `protobuf:"varint,2,opt,name=LimitVIP,proto3" json:"LimitVIP,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserRecommendCheckRep) Reset()         { *m = UserRecommendCheckRep{} }
func (m *UserRecommendCheckRep) String() string { return proto.CompactTextString(m) }
func (*UserRecommendCheckRep) ProtoMessage()    {}
func (*UserRecommendCheckRep) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{11}
}
func (m *UserRecommendCheckRep) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserRecommendCheckRep) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserRecommendCheckRep.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserRecommendCheckRep) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserRecommendCheckRep.Merge(m, src)
}
func (m *UserRecommendCheckRep) XXX_Size() int {
	return m.Size()
}
func (m *UserRecommendCheckRep) XXX_DiscardUnknown() {
	xxx_messageInfo_UserRecommendCheckRep.DiscardUnknown(m)
}

var xxx_messageInfo_UserRecommendCheckRep proto.InternalMessageInfo

func (m *UserRecommendCheckRep) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

func (m *UserRecommendCheckRep) GetLimitVIP() int32 {
	if m != nil {
		return m.LimitVIP
	}
	return 0
}

type UserIgnoreCheckRep struct {
	Status               bool     `protobuf:"varint,1,opt,name=Status,proto3" json:"Status,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserIgnoreCheckRep) Reset()         { *m = UserIgnoreCheckRep{} }
func (m *UserIgnoreCheckRep) String() string { return proto.CompactTextString(m) }
func (*UserIgnoreCheckRep) ProtoMessage()    {}
func (*UserIgnoreCheckRep) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{12}
}
func (m *UserIgnoreCheckRep) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserIgnoreCheckRep) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserIgnoreCheckRep.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserIgnoreCheckRep) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserIgnoreCheckRep.Merge(m, src)
}
func (m *UserIgnoreCheckRep) XXX_Size() int {
	return m.Size()
}
func (m *UserIgnoreCheckRep) XXX_DiscardUnknown() {
	xxx_messageInfo_UserIgnoreCheckRep.DiscardUnknown(m)
}

var xxx_messageInfo_UserIgnoreCheckRep proto.InternalMessageInfo

func (m *UserIgnoreCheckRep) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

type IgnoreSlice struct {
	Ignores              []*UserIgnore `protobuf:"bytes,1,rep,name=Ignores,proto3" json:"Ignores,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *IgnoreSlice) Reset()         { *m = IgnoreSlice{} }
func (m *IgnoreSlice) String() string { return proto.CompactTextString(m) }
func (*IgnoreSlice) ProtoMessage()    {}
func (*IgnoreSlice) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{13}
}
func (m *IgnoreSlice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IgnoreSlice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IgnoreSlice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IgnoreSlice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IgnoreSlice.Merge(m, src)
}
func (m *IgnoreSlice) XXX_Size() int {
	return m.Size()
}
func (m *IgnoreSlice) XXX_DiscardUnknown() {
	xxx_messageInfo_IgnoreSlice.DiscardUnknown(m)
}

var xxx_messageInfo_IgnoreSlice proto.InternalMessageInfo

func (m *IgnoreSlice) GetIgnores() []*UserIgnore {
	if m != nil {
		return m.Ignores
	}
	return nil
}

type IgnoreNone struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IgnoreNone) Reset()         { *m = IgnoreNone{} }
func (m *IgnoreNone) String() string { return proto.CompactTextString(m) }
func (*IgnoreNone) ProtoMessage()    {}
func (*IgnoreNone) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{14}
}
func (m *IgnoreNone) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IgnoreNone) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IgnoreNone.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IgnoreNone) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IgnoreNone.Merge(m, src)
}
func (m *IgnoreNone) XXX_Size() int {
	return m.Size()
}
func (m *IgnoreNone) XXX_DiscardUnknown() {
	xxx_messageInfo_IgnoreNone.DiscardUnknown(m)
}

var xxx_messageInfo_IgnoreNone proto.InternalMessageInfo

type UserAlbumReq struct {
	UserID               int32    `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	ForumID              int32    `protobuf:"varint,2,opt,name=ForumID,proto3" json:"ForumID,omitempty"`
	FriendID             int32    `protobuf:"varint,3,opt,name=FriendID,proto3" json:"FriendID,omitempty"`
	Limit                int64    `protobuf:"varint,4,opt,name=Limit,proto3" json:"Limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserAlbumReq) Reset()         { *m = UserAlbumReq{} }
func (m *UserAlbumReq) String() string { return proto.CompactTextString(m) }
func (*UserAlbumReq) ProtoMessage()    {}
func (*UserAlbumReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{15}
}
func (m *UserAlbumReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserAlbumReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserAlbumReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserAlbumReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserAlbumReq.Merge(m, src)
}
func (m *UserAlbumReq) XXX_Size() int {
	return m.Size()
}
func (m *UserAlbumReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UserAlbumReq.DiscardUnknown(m)
}

var xxx_messageInfo_UserAlbumReq proto.InternalMessageInfo

func (m *UserAlbumReq) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *UserAlbumReq) GetForumID() int32 {
	if m != nil {
		return m.ForumID
	}
	return 0
}

func (m *UserAlbumReq) GetFriendID() int32 {
	if m != nil {
		return m.FriendID
	}
	return 0
}

func (m *UserAlbumReq) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type UserAlbumRep struct {
	Medias               []*Media `protobuf:"bytes,1,rep,name=Medias,proto3" json:"Medias,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserAlbumRep) Reset()         { *m = UserAlbumRep{} }
func (m *UserAlbumRep) String() string { return proto.CompactTextString(m) }
func (*UserAlbumRep) ProtoMessage()    {}
func (*UserAlbumRep) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{16}
}
func (m *UserAlbumRep) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserAlbumRep) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserAlbumRep.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserAlbumRep) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserAlbumRep.Merge(m, src)
}
func (m *UserAlbumRep) XXX_Size() int {
	return m.Size()
}
func (m *UserAlbumRep) XXX_DiscardUnknown() {
	xxx_messageInfo_UserAlbumRep.DiscardUnknown(m)
}

var xxx_messageInfo_UserAlbumRep proto.InternalMessageInfo

func (m *UserAlbumRep) GetMedias() []*Media {
	if m != nil {
		return m.Medias
	}
	return nil
}

type UserStatisticsReq struct {
	Vistor               int32    `protobuf:"varint,1,opt,name=Vistor,proto3" json:"Vistor,omitempty"`
	CreateBy             int32    `protobuf:"varint,2,opt,name=CreateBy,proto3" json:"CreateBy,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserStatisticsReq) Reset()         { *m = UserStatisticsReq{} }
func (m *UserStatisticsReq) String() string { return proto.CompactTextString(m) }
func (*UserStatisticsReq) ProtoMessage()    {}
func (*UserStatisticsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{17}
}
func (m *UserStatisticsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserStatisticsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserStatisticsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserStatisticsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserStatisticsReq.Merge(m, src)
}
func (m *UserStatisticsReq) XXX_Size() int {
	return m.Size()
}
func (m *UserStatisticsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UserStatisticsReq.DiscardUnknown(m)
}

var xxx_messageInfo_UserStatisticsReq proto.InternalMessageInfo

func (m *UserStatisticsReq) GetVistor() int32 {
	if m != nil {
		return m.Vistor
	}
	return 0
}

func (m *UserStatisticsReq) GetCreateBy() int32 {
	if m != nil {
		return m.CreateBy
	}
	return 0
}

type UserStatisticsRep struct {
	Forum                int64    `protobuf:"varint,1,opt,name=Forum,proto3" json:"Forum,omitempty"`
	Follow               int64    `protobuf:"varint,2,opt,name=Follow,proto3" json:"Follow,omitempty"`
	Thumb                int64    `protobuf:"varint,3,opt,name=Thumb,proto3" json:"Thumb,omitempty"`
	Fans                 int64    `protobuf:"varint,4,opt,name=Fans,proto3" json:"Fans,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserStatisticsRep) Reset()         { *m = UserStatisticsRep{} }
func (m *UserStatisticsRep) String() string { return proto.CompactTextString(m) }
func (*UserStatisticsRep) ProtoMessage()    {}
func (*UserStatisticsRep) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{18}
}
func (m *UserStatisticsRep) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserStatisticsRep) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserStatisticsRep.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserStatisticsRep) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserStatisticsRep.Merge(m, src)
}
func (m *UserStatisticsRep) XXX_Size() int {
	return m.Size()
}
func (m *UserStatisticsRep) XXX_DiscardUnknown() {
	xxx_messageInfo_UserStatisticsRep.DiscardUnknown(m)
}

var xxx_messageInfo_UserStatisticsRep proto.InternalMessageInfo

func (m *UserStatisticsRep) GetForum() int64 {
	if m != nil {
		return m.Forum
	}
	return 0
}

func (m *UserStatisticsRep) GetFollow() int64 {
	if m != nil {
		return m.Follow
	}
	return 0
}

func (m *UserStatisticsRep) GetThumb() int64 {
	if m != nil {
		return m.Thumb
	}
	return 0
}

func (m *UserStatisticsRep) GetFans() int64 {
	if m != nil {
		return m.Fans
	}
	return 0
}

type UserIgnore struct {
	// ID 主键
	// @inject_tag: db:"id"
	ID int32 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty" db:"id"`
	// UserIgnoreID id
	// @inject_tag: db:"ignore_id"
	IgnoreID int64 `protobuf:"varint,2,opt,name=IgnoreID,proto3" json:"IgnoreID,omitempty" db:"ignore_id"`
	// @inject_tag: db:"look"
	Look int32 `protobuf:"varint,3,opt,name=Look,proto3" json:"Look,omitempty" db:"look"`
	// UserID 朋友
	// @inject_tag: db:"user_id"
	UserID int32 `protobuf:"varint,4,opt,name=UserID,proto3" json:"UserID,omitempty" db:"user_id"`
	// CreateBy 创建人
	// @inject_tag: db:"create_by"
	CreateBy int32 `protobuf:"varint,5,opt,name=CreateBy,proto3" json:"CreateBy,omitempty" db:"create_by"`
	// CreateAt 创建时间
	// @inject_tag: db:"create_at"
	CreateAt             int64    `protobuf:"varint,6,opt,name=CreateAt,proto3" json:"CreateAt,omitempty" db:"create_at"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserIgnore) Reset()         { *m = UserIgnore{} }
func (m *UserIgnore) String() string { return proto.CompactTextString(m) }
func (*UserIgnore) ProtoMessage()    {}
func (*UserIgnore) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{19}
}
func (m *UserIgnore) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserIgnore) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserIgnore.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserIgnore) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserIgnore.Merge(m, src)
}
func (m *UserIgnore) XXX_Size() int {
	return m.Size()
}
func (m *UserIgnore) XXX_DiscardUnknown() {
	xxx_messageInfo_UserIgnore.DiscardUnknown(m)
}

var xxx_messageInfo_UserIgnore proto.InternalMessageInfo

func (m *UserIgnore) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *UserIgnore) GetIgnoreID() int64 {
	if m != nil {
		return m.IgnoreID
	}
	return 0
}

func (m *UserIgnore) GetLook() int32 {
	if m != nil {
		return m.Look
	}
	return 0
}

func (m *UserIgnore) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *UserIgnore) GetCreateBy() int32 {
	if m != nil {
		return m.CreateBy
	}
	return 0
}

func (m *UserIgnore) GetCreateAt() int64 {
	if m != nil {
		return m.CreateAt
	}
	return 0
}

type UserStatus struct {
	// ID 主键
	// @inject_tag: db:"id"
	ID int32 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty" db:"id"`
	// UserID 用户
	// @inject_tag: db:"user_id"
	UserID int32 `protobuf:"varint,2,opt,name=UserID,proto3" json:"UserID,omitempty" db:"user_id"`
	// ForumCount 发帖数
	// @inject_tag: db:"forum_count"
	ForumCount int64 `protobuf:"varint,3,opt,name=ForumCount,proto3" json:"ForumCount,omitempty" db:"forum_count"`
	// FollowCount 关注数
	// @inject_tag: db:"follow_count"
	FollowCount int64 `protobuf:"varint,4,opt,name=FollowCount,proto3" json:"FollowCount,omitempty" db:"follow_count"`
	// ThumbCount 点赞数
	// @inject_tag: db:"thumb_count"
	ThumbCount int64 `protobuf:"varint,5,opt,name=ThumbCount,proto3" json:"ThumbCount,omitempty" db:"thumb_count"`
	// FansCount 粉丝数
	// @inject_tag: db:"fans_count"
	FansCount int64 `protobuf:"varint,6,opt,name=FansCount,proto3" json:"FansCount,omitempty" db:"fans_count"`
	// Version 版本号
	// @inject_tag: db:"friend_version"
	FriendVersion int64 `protobuf:"varint,7,opt,name=FriendVersion,proto3" json:"FriendVersion,omitempty" db:"friend_version"`
	// Version 版本号
	// @inject_tag: db:"follow_version"
	FollowVersion int64 `protobuf:"varint,8,opt,name=FollowVersion,proto3" json:"FollowVersion,omitempty" db:"follow_version"`
	// Version 版本号
	// @inject_tag: db:"recommend_version_read"
	RecommendVersionRead int64 `protobuf:"varint,9,opt,name=RecommendVersionRead,proto3" json:"RecommendVersionRead,omitempty" db:"recommend_version_read"`
	// Version 版本号
	// @inject_tag: db:"friend_version_read"
	FriendVersionRead int64 `protobuf:"varint,10,opt,name=FriendVersionRead,proto3" json:"FriendVersionRead,omitempty" db:"friend_version_read"`
	// Version 版本号
	// @inject_tag: db:"follow_version_read"
	FollowVersionRead int64 `protobuf:"varint,11,opt,name=FollowVersionRead,proto3" json:"FollowVersionRead,omitempty" db:"follow_version_read"`
	// Version 背景图
	// @inject_tag: db:"home_background"
	HomeBackground string `protobuf:"bytes,12,opt,name=HomeBackground,proto3" json:"HomeBackground,omitempty" db:"home_background"`
	// CreateAt 创建时间
	// @inject_tag: db:"create_at"
	CreateAt int64 `protobuf:"varint,13,opt,name=CreateAt,proto3" json:"CreateAt,omitempty" db:"create_at"`
	// CreateAt 创建时间
	// @inject_tag: db:"update_at"
	UpdateAt int64 `protobuf:"varint,14,opt,name=UpdateAt,proto3" json:"UpdateAt,omitempty" db:"update_at"`
	// RecommendVersion 推荐版本号
	RecommendVersion     int64                  `protobuf:"varint,15,opt,name=RecommendVersion,proto3" json:"RecommendVersion,omitempty"`
	User                 *imapigateway.UserInfo `protobuf:"bytes,16,opt,name=User,proto3" json:"User,omitempty"`
	IsFriend             bool                   `protobuf:"varint,17,opt,name=IsFriend,proto3" json:"IsFriend,omitempty"`
	RecommendUID         int32                  `protobuf:"varint,18,opt,name=RecommendUID,proto3" json:"RecommendUID,omitempty"`
	FriendUID            int32                  `protobuf:"varint,19,opt,name=FriendUID,proto3" json:"FriendUID,omitempty"`
	FollowUID            int32                  `protobuf:"varint,20,opt,name=FollowUID,proto3" json:"FollowUID,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *UserStatus) Reset()         { *m = UserStatus{} }
func (m *UserStatus) String() string { return proto.CompactTextString(m) }
func (*UserStatus) ProtoMessage()    {}
func (*UserStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{20}
}
func (m *UserStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserStatus.Merge(m, src)
}
func (m *UserStatus) XXX_Size() int {
	return m.Size()
}
func (m *UserStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_UserStatus.DiscardUnknown(m)
}

var xxx_messageInfo_UserStatus proto.InternalMessageInfo

func (m *UserStatus) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *UserStatus) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *UserStatus) GetForumCount() int64 {
	if m != nil {
		return m.ForumCount
	}
	return 0
}

func (m *UserStatus) GetFollowCount() int64 {
	if m != nil {
		return m.FollowCount
	}
	return 0
}

func (m *UserStatus) GetThumbCount() int64 {
	if m != nil {
		return m.ThumbCount
	}
	return 0
}

func (m *UserStatus) GetFansCount() int64 {
	if m != nil {
		return m.FansCount
	}
	return 0
}

func (m *UserStatus) GetFriendVersion() int64 {
	if m != nil {
		return m.FriendVersion
	}
	return 0
}

func (m *UserStatus) GetFollowVersion() int64 {
	if m != nil {
		return m.FollowVersion
	}
	return 0
}

func (m *UserStatus) GetRecommendVersionRead() int64 {
	if m != nil {
		return m.RecommendVersionRead
	}
	return 0
}

func (m *UserStatus) GetFriendVersionRead() int64 {
	if m != nil {
		return m.FriendVersionRead
	}
	return 0
}

func (m *UserStatus) GetFollowVersionRead() int64 {
	if m != nil {
		return m.FollowVersionRead
	}
	return 0
}

func (m *UserStatus) GetHomeBackground() string {
	if m != nil {
		return m.HomeBackground
	}
	return ""
}

func (m *UserStatus) GetCreateAt() int64 {
	if m != nil {
		return m.CreateAt
	}
	return 0
}

func (m *UserStatus) GetUpdateAt() int64 {
	if m != nil {
		return m.UpdateAt
	}
	return 0
}

func (m *UserStatus) GetRecommendVersion() int64 {
	if m != nil {
		return m.RecommendVersion
	}
	return 0
}

func (m *UserStatus) GetUser() *imapigateway.UserInfo {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *UserStatus) GetIsFriend() bool {
	if m != nil {
		return m.IsFriend
	}
	return false
}

func (m *UserStatus) GetRecommendUID() int32 {
	if m != nil {
		return m.RecommendUID
	}
	return 0
}

func (m *UserStatus) GetFriendUID() int32 {
	if m != nil {
		return m.FriendUID
	}
	return 0
}

func (m *UserStatus) GetFollowUID() int32 {
	if m != nil {
		return m.FollowUID
	}
	return 0
}

// UserRecommendVersion ...
type UserRecommendVersion struct {
	// ID 主键
	// @inject_tag: db:"id"
	ID int32 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty" db:"id"`
	// Version 推荐版本号
	// @inject_tag: db:"version"
	Version              string   `protobuf:"bytes,2,opt,name=Version,proto3" json:"Version,omitempty" db:"version"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserRecommendVersion) Reset()         { *m = UserRecommendVersion{} }
func (m *UserRecommendVersion) String() string { return proto.CompactTextString(m) }
func (*UserRecommendVersion) ProtoMessage()    {}
func (*UserRecommendVersion) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{21}
}
func (m *UserRecommendVersion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserRecommendVersion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserRecommendVersion.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserRecommendVersion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserRecommendVersion.Merge(m, src)
}
func (m *UserRecommendVersion) XXX_Size() int {
	return m.Size()
}
func (m *UserRecommendVersion) XXX_DiscardUnknown() {
	xxx_messageInfo_UserRecommendVersion.DiscardUnknown(m)
}

var xxx_messageInfo_UserRecommendVersion proto.InternalMessageInfo

func (m *UserRecommendVersion) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *UserRecommendVersion) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

type TagAddReq struct {
	Tag                  *Tag       `protobuf:"bytes,1,opt,name=Tag,proto3" json:"Tag,omitempty"`
	UserTags             []*UserTag `protobuf:"bytes,2,rep,name=UserTags,proto3" json:"UserTags,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *TagAddReq) Reset()         { *m = TagAddReq{} }
func (m *TagAddReq) String() string { return proto.CompactTextString(m) }
func (*TagAddReq) ProtoMessage()    {}
func (*TagAddReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{22}
}
func (m *TagAddReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TagAddReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TagAddReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TagAddReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TagAddReq.Merge(m, src)
}
func (m *TagAddReq) XXX_Size() int {
	return m.Size()
}
func (m *TagAddReq) XXX_DiscardUnknown() {
	xxx_messageInfo_TagAddReq.DiscardUnknown(m)
}

var xxx_messageInfo_TagAddReq proto.InternalMessageInfo

func (m *TagAddReq) GetTag() *Tag {
	if m != nil {
		return m.Tag
	}
	return nil
}

func (m *TagAddReq) GetUserTags() []*UserTag {
	if m != nil {
		return m.UserTags
	}
	return nil
}

type TagAddRep struct {
	Tag                  *Tag     `protobuf:"bytes,1,opt,name=Tag,proto3" json:"Tag,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TagAddRep) Reset()         { *m = TagAddRep{} }
func (m *TagAddRep) String() string { return proto.CompactTextString(m) }
func (*TagAddRep) ProtoMessage()    {}
func (*TagAddRep) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{23}
}
func (m *TagAddRep) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TagAddRep) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TagAddRep.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TagAddRep) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TagAddRep.Merge(m, src)
}
func (m *TagAddRep) XXX_Size() int {
	return m.Size()
}
func (m *TagAddRep) XXX_DiscardUnknown() {
	xxx_messageInfo_TagAddRep.DiscardUnknown(m)
}

var xxx_messageInfo_TagAddRep proto.InternalMessageInfo

func (m *TagAddRep) GetTag() *Tag {
	if m != nil {
		return m.Tag
	}
	return nil
}

type UserTags struct {
	Tag                  *Tag       `protobuf:"bytes,1,opt,name=Tag,proto3" json:"Tag,omitempty"`
	TagUsers             []*UserTag `protobuf:"bytes,2,rep,name=TagUsers,proto3" json:"TagUsers,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *UserTags) Reset()         { *m = UserTags{} }
func (m *UserTags) String() string { return proto.CompactTextString(m) }
func (*UserTags) ProtoMessage()    {}
func (*UserTags) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{24}
}
func (m *UserTags) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserTags) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserTags.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserTags) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserTags.Merge(m, src)
}
func (m *UserTags) XXX_Size() int {
	return m.Size()
}
func (m *UserTags) XXX_DiscardUnknown() {
	xxx_messageInfo_UserTags.DiscardUnknown(m)
}

var xxx_messageInfo_UserTags proto.InternalMessageInfo

func (m *UserTags) GetTag() *Tag {
	if m != nil {
		return m.Tag
	}
	return nil
}

func (m *UserTags) GetTagUsers() []*UserTag {
	if m != nil {
		return m.TagUsers
	}
	return nil
}

type TagGetReq struct {
	UserID               int32    `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TagGetReq) Reset()         { *m = TagGetReq{} }
func (m *TagGetReq) String() string { return proto.CompactTextString(m) }
func (*TagGetReq) ProtoMessage()    {}
func (*TagGetReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{25}
}
func (m *TagGetReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TagGetReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TagGetReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TagGetReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TagGetReq.Merge(m, src)
}
func (m *TagGetReq) XXX_Size() int {
	return m.Size()
}
func (m *TagGetReq) XXX_DiscardUnknown() {
	xxx_messageInfo_TagGetReq.DiscardUnknown(m)
}

var xxx_messageInfo_TagGetReq proto.InternalMessageInfo

func (m *TagGetReq) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

type TagGetRep struct {
	UserTags             []*UserTags `protobuf:"bytes,1,rep,name=UserTags,proto3" json:"UserTags,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *TagGetRep) Reset()         { *m = TagGetRep{} }
func (m *TagGetRep) String() string { return proto.CompactTextString(m) }
func (*TagGetRep) ProtoMessage()    {}
func (*TagGetRep) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{26}
}
func (m *TagGetRep) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TagGetRep) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TagGetRep.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TagGetRep) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TagGetRep.Merge(m, src)
}
func (m *TagGetRep) XXX_Size() int {
	return m.Size()
}
func (m *TagGetRep) XXX_DiscardUnknown() {
	xxx_messageInfo_TagGetRep.DiscardUnknown(m)
}

var xxx_messageInfo_TagGetRep proto.InternalMessageInfo

func (m *TagGetRep) GetUserTags() []*UserTags {
	if m != nil {
		return m.UserTags
	}
	return nil
}

type Tag struct {
	// ID 主键
	// @inject_tag: db:"id"
	ID int32 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty" db:"id"`
	// TagID 标签ID
	// @inject_tag: db:"tag_id"
	TagID int64 `protobuf:"varint,2,opt,name=TagID,proto3" json:"TagID,omitempty" db:"tag_id"`
	// TagName 标签名称(*此字段必传)
	// @inject_tag: db:"tag_name"
	TagName string `protobuf:"bytes,3,opt,name=TagName,proto3" json:"TagName,omitempty" db:"tag_name"`
	// CreateAt 创建时间
	// @inject_tag: db:"create_at"
	CreateAt int64 `protobuf:"varint,4,opt,name=CreateAt,proto3" json:"CreateAt,omitempty" db:"create_at"`
	// CreateBy 创建人
	// @inject_tag: db:"create_by"
	CreateBy             int32    `protobuf:"varint,5,opt,name=CreateBy,proto3" json:"CreateBy,omitempty" db:"create_by"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Tag) Reset()         { *m = Tag{} }
func (m *Tag) String() string { return proto.CompactTextString(m) }
func (*Tag) ProtoMessage()    {}
func (*Tag) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{27}
}
func (m *Tag) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tag) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tag.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tag) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tag.Merge(m, src)
}
func (m *Tag) XXX_Size() int {
	return m.Size()
}
func (m *Tag) XXX_DiscardUnknown() {
	xxx_messageInfo_Tag.DiscardUnknown(m)
}

var xxx_messageInfo_Tag proto.InternalMessageInfo

func (m *Tag) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Tag) GetTagID() int64 {
	if m != nil {
		return m.TagID
	}
	return 0
}

func (m *Tag) GetTagName() string {
	if m != nil {
		return m.TagName
	}
	return ""
}

func (m *Tag) GetCreateAt() int64 {
	if m != nil {
		return m.CreateAt
	}
	return 0
}

func (m *Tag) GetCreateBy() int32 {
	if m != nil {
		return m.CreateBy
	}
	return 0
}

type UserTag struct {
	// ID 主键
	// @inject_tag: db:"id"
	ID int32 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty" db:"id"`
	// UserTagID 用户标签ID
	// @inject_tag: db:"user_tag_id"
	UserTagID int64 `protobuf:"varint,2,opt,name=UserTagID,proto3" json:"UserTagID,omitempty" db:"user_tag_id"`
	// ForumID 帖子ID
	// @inject_tag: db:"forum_id"
	// int32 ForumID  =3;
	// TagID 标签ID
	// @inject_tag: db:"tag_id"
	TagID int64 `protobuf:"varint,3,opt,name=TagID,proto3" json:"TagID,omitempty" db:"tag_id"`
	// UserID 用户(*此字段必传)
	// @inject_tag: db:"user_id"
	UserID int32 `protobuf:"varint,4,opt,name=UserID,proto3" json:"UserID,omitempty" db:"user_id"`
	// CreateAt 创建时间
	// @inject_tag: db:"create_at"
	CreateAt int64 `protobuf:"varint,5,opt,name=CreateAt,proto3" json:"CreateAt,omitempty" db:"create_at"`
	// CreateBy 创建人
	// @inject_tag: db:"create_by"
	CreateBy             int32    `protobuf:"varint,6,opt,name=CreateBy,proto3" json:"CreateBy,omitempty" db:"create_by"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserTag) Reset()         { *m = UserTag{} }
func (m *UserTag) String() string { return proto.CompactTextString(m) }
func (*UserTag) ProtoMessage()    {}
func (*UserTag) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{28}
}
func (m *UserTag) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserTag) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserTag.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserTag) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserTag.Merge(m, src)
}
func (m *UserTag) XXX_Size() int {
	return m.Size()
}
func (m *UserTag) XXX_DiscardUnknown() {
	xxx_messageInfo_UserTag.DiscardUnknown(m)
}

var xxx_messageInfo_UserTag proto.InternalMessageInfo

func (m *UserTag) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *UserTag) GetUserTagID() int64 {
	if m != nil {
		return m.UserTagID
	}
	return 0
}

func (m *UserTag) GetTagID() int64 {
	if m != nil {
		return m.TagID
	}
	return 0
}

func (m *UserTag) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *UserTag) GetCreateAt() int64 {
	if m != nil {
		return m.CreateAt
	}
	return 0
}

func (m *UserTag) GetCreateBy() int32 {
	if m != nil {
		return m.CreateBy
	}
	return 0
}

type UserRecommend struct {
	// ID 主键
	// @inject_tag: db:"id"
	ID int32 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty" db:"id"`
	// ForumType 帖子类型
	// @inject_tag: db:"forum_type"
	ForumType int64 `protobuf:"varint,2,opt,name=ForumType,proto3" json:"ForumType,omitempty" db:"forum_type"`
	// UserID 用户(*此字段必传)
	// @inject_tag: db:"user_id"
	UserID int32 `protobuf:"varint,4,opt,name=UserID,proto3" json:"UserID,omitempty" db:"user_id"`
	// CreateAt 创建时间
	// @inject_tag: db:"create_at"
	CreateAt int64 `protobuf:"varint,5,opt,name=CreateAt,proto3" json:"CreateAt,omitempty" db:"create_at"`
	// CreateBy 创建人
	// @inject_tag: db:"create_by"
	CreateBy int32 `protobuf:"varint,6,opt,name=CreateBy,proto3" json:"CreateBy,omitempty" db:"create_by"`
	// Mark 备注
	// @inject_tag: db:"mark"
	Mark string `protobuf:"bytes,7,opt,name=Mark,proto3" json:"Mark,omitempty" db:"mark"`
	// Mark 最低评论等级
	// @inject_tag: db:"limit_vip"
	LimitVIP             int32    `protobuf:"varint,8,opt,name=LimitVIP,proto3" json:"LimitVIP,omitempty" db:"limit_vip"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserRecommend) Reset()         { *m = UserRecommend{} }
func (m *UserRecommend) String() string { return proto.CompactTextString(m) }
func (*UserRecommend) ProtoMessage()    {}
func (*UserRecommend) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{29}
}
func (m *UserRecommend) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserRecommend) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserRecommend.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserRecommend) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserRecommend.Merge(m, src)
}
func (m *UserRecommend) XXX_Size() int {
	return m.Size()
}
func (m *UserRecommend) XXX_DiscardUnknown() {
	xxx_messageInfo_UserRecommend.DiscardUnknown(m)
}

var xxx_messageInfo_UserRecommend proto.InternalMessageInfo

func (m *UserRecommend) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *UserRecommend) GetForumType() int64 {
	if m != nil {
		return m.ForumType
	}
	return 0
}

func (m *UserRecommend) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *UserRecommend) GetCreateAt() int64 {
	if m != nil {
		return m.CreateAt
	}
	return 0
}

func (m *UserRecommend) GetCreateBy() int32 {
	if m != nil {
		return m.CreateBy
	}
	return 0
}

func (m *UserRecommend) GetMark() string {
	if m != nil {
		return m.Mark
	}
	return ""
}

func (m *UserRecommend) GetLimitVIP() int32 {
	if m != nil {
		return m.LimitVIP
	}
	return 0
}

type Page struct {
	// 总条数
	TotalRows int64 `protobuf:"varint,1,opt,name=TotalRows,proto3" json:"TotalRows,omitempty"`
	// 总页数
	PageCount int64 `protobuf:"varint,2,opt,name=PageCount,proto3" json:"PageCount,omitempty"`
	// 页数大小
	PageSize int64 `protobuf:"varint,3,opt,name=PageSize,proto3" json:"PageSize,omitempty"`
	// 当前页
	CurrentPage int64 `protobuf:"varint,4,opt,name=CurrentPage,proto3" json:"CurrentPage,omitempty"`
	// 偏移量
	Offset int64 `protobuf:"varint,5,opt,name=Offset,proto3" json:"Offset,omitempty"`
	// 长度
	Limit int64 `protobuf:"varint,6,opt,name=Limit,proto3" json:"Limit,omitempty"`
	// 排序字段
	Order string `protobuf:"bytes,7,opt,name=Order,proto3" json:"Order,omitempty"`
	// 排序方法 (AES,DESC)
	Sort                 string   `protobuf:"bytes,8,opt,name=Sort,proto3" json:"Sort,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Page) Reset()         { *m = Page{} }
func (m *Page) String() string { return proto.CompactTextString(m) }
func (*Page) ProtoMessage()    {}
func (*Page) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{30}
}
func (m *Page) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Page) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Page.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Page) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Page.Merge(m, src)
}
func (m *Page) XXX_Size() int {
	return m.Size()
}
func (m *Page) XXX_DiscardUnknown() {
	xxx_messageInfo_Page.DiscardUnknown(m)
}

var xxx_messageInfo_Page proto.InternalMessageInfo

func (m *Page) GetTotalRows() int64 {
	if m != nil {
		return m.TotalRows
	}
	return 0
}

func (m *Page) GetPageCount() int64 {
	if m != nil {
		return m.PageCount
	}
	return 0
}

func (m *Page) GetPageSize() int64 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *Page) GetCurrentPage() int64 {
	if m != nil {
		return m.CurrentPage
	}
	return 0
}

func (m *Page) GetOffset() int64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *Page) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *Page) GetOrder() string {
	if m != nil {
		return m.Order
	}
	return ""
}

func (m *Page) GetSort() string {
	if m != nil {
		return m.Sort
	}
	return ""
}

func init() {
	proto.RegisterType((*UserIgnoresAllResp)(nil), "moment.UserIgnoresAllResp")
	proto.RegisterType((*UserIgnoreMeGetResp)(nil), "moment.UserIgnoreMeGetResp")
	proto.RegisterType((*UserContactsSyncReq)(nil), "moment.UserContactsSyncReq")
	proto.RegisterType((*UserContactsSyncRep)(nil), "moment.UserContactsSyncRep")
	proto.RegisterType((*UserAlbumsReq)(nil), "moment.UserAlbumsReq")
	proto.RegisterType((*UserAlbumsRep)(nil), "moment.UserAlbumsRep")
	proto.RegisterType((*UserVersionGetRep)(nil), "moment.UserVersionGetRep")
	proto.RegisterType((*UserVersionUpdateReq)(nil), "moment.UserVersionUpdateReq")
	proto.RegisterType((*UserVersionUpdateRep)(nil), "moment.UserVersionUpdateRep")
	proto.RegisterType((*UserAllIDReq)(nil), "moment.UserAllIDReq")
	proto.RegisterType((*UserAllIDRep)(nil), "moment.UserAllIDRep")
	proto.RegisterType((*UserRecommendCheckRep)(nil), "moment.UserRecommendCheckRep")
	proto.RegisterType((*UserIgnoreCheckRep)(nil), "moment.UserIgnoreCheckRep")
	proto.RegisterType((*IgnoreSlice)(nil), "moment.IgnoreSlice")
	proto.RegisterType((*IgnoreNone)(nil), "moment.IgnoreNone")
	proto.RegisterType((*UserAlbumReq)(nil), "moment.UserAlbumReq")
	proto.RegisterType((*UserAlbumRep)(nil), "moment.UserAlbumRep")
	proto.RegisterType((*UserStatisticsReq)(nil), "moment.UserStatisticsReq")
	proto.RegisterType((*UserStatisticsRep)(nil), "moment.UserStatisticsRep")
	proto.RegisterType((*UserIgnore)(nil), "moment.UserIgnore")
	proto.RegisterType((*UserStatus)(nil), "moment.UserStatus")
	proto.RegisterType((*UserRecommendVersion)(nil), "moment.UserRecommendVersion")
	proto.RegisterType((*TagAddReq)(nil), "moment.TagAddReq")
	proto.RegisterType((*TagAddRep)(nil), "moment.TagAddRep")
	proto.RegisterType((*UserTags)(nil), "moment.UserTags")
	proto.RegisterType((*TagGetReq)(nil), "moment.TagGetReq")
	proto.RegisterType((*TagGetRep)(nil), "moment.TagGetRep")
	proto.RegisterType((*Tag)(nil), "moment.Tag")
	proto.RegisterType((*UserTag)(nil), "moment.UserTag")
	proto.RegisterType((*UserRecommend)(nil), "moment.UserRecommend")
	proto.RegisterType((*Page)(nil), "moment.Page")
}

func init() { proto.RegisterFile("base.proto", fileDescriptor_db1b6b0986796150) }

var fileDescriptor_db1b6b0986796150 = []byte{
	// 1524 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0x5f, 0x6f, 0x1b, 0x45,
	0x10, 0xf7, 0xc5, 0x7f, 0x62, 0xaf, 0x93, 0x34, 0xd9, 0xa6, 0x91, 0x39, 0x4a, 0x14, 0x2d, 0x50,
	0x45, 0x25, 0x32, 0xc8, 0x88, 0x87, 0xd2, 0x56, 0xc2, 0x76, 0x48, 0x89, 0x68, 0xda, 0x72, 0x71,
	0xc2, 0x0b, 0x2f, 0x17, 0x7b, 0xeb, 0x9e, 0xe2, 0xfb, 0xc3, 0xdd, 0x99, 0x12, 0x24, 0x3e, 0x09,
	0xe5, 0xa3, 0xf0, 0xc6, 0x03, 0x8f, 0x88, 0x27, 0xde, 0x40, 0xfd, 0x24, 0x68, 0x66, 0x76, 0xef,
	0x9f, 0x2f, 0x49, 0x2b, 0xf1, 0x76, 0xf3, 0xdb, 0x99, 0xd9, 0xdf, 0xec, 0xce, 0xce, 0xce, 0x1e,
	0x63, 0x67, 0x76, 0x24, 0xbb, 0x41, 0xe8, 0xc7, 0x3e, 0x6f, 0xb8, 0xbe, 0x2b, 0xbd, 0xd8, 0x6c,
	0xbb, 0x72, 0xe2, 0xd8, 0x04, 0x9a, 0x2b, 0x63, 0xdf, 0x75, 0x7d, 0x8f, 0x24, 0xd1, 0x65, 0xfc,
	0x24, 0x92, 0xe1, 0xe1, 0xd4, 0xf3, 0x43, 0x19, 0xf5, 0x67, 0x33, 0x4b, 0x46, 0x01, 0xef, 0xb0,
	0x65, 0x44, 0xf7, 0xa3, 0x8e, 0xb1, 0x53, 0xdd, 0xad, 0x5b, 0x5a, 0x14, 0x1f, 0xb3, 0x9b, 0xa9,
	0xfe, 0x91, 0x7c, 0x24, 0xe3, 0x6b, 0x0c, 0xc6, 0x64, 0x30, 0xf4, 0xbd, 0xd8, 0x1e, 0xc7, 0xd1,
	0xf1, 0x85, 0x37, 0xb6, 0xe4, 0xf7, 0x7c, 0x8b, 0x35, 0xfa, 0xe3, 0xd8, 0xf1, 0xbd, 0x8e, 0xb1,
	0x63, 0xec, 0xd6, 0x2d, 0x25, 0x01, 0x4e, 0x96, 0x9d, 0x25, 0xc2, 0x49, 0xe2, 0xb7, 0x59, 0x4b,
	0xb9, 0x38, 0xdc, 0xef, 0x54, 0x71, 0x8a, 0x14, 0x10, 0xf7, 0xcb, 0x26, 0x09, 0x38, 0x67, 0xb5,
	0xa1, 0x3f, 0x91, 0x6a, 0x0a, 0xfc, 0xe6, 0xeb, 0xac, 0x7a, 0x14, 0x4d, 0xd1, 0x7b, 0xcb, 0x82,
	0x4f, 0x31, 0x64, 0xab, 0x60, 0xdc, 0x9f, 0x9d, 0xcd, 0xdd, 0x48, 0x71, 0x53, 0x1c, 0x8c, 0x1c,
	0x07, 0x93, 0x35, 0x0f, 0x42, 0x47, 0x7a, 0x93, 0x84, 0x5d, 0x22, 0x8b, 0xef, 0xf2, 0x4e, 0xde,
	0x70, 0x6e, 0xfe, 0x21, 0x6b, 0x1c, 0xc1, 0xde, 0x44, 0x18, 0x53, 0xbb, 0xb7, 0xda, 0xa5, 0x2d,
	0xeb, 0x22, 0x6a, 0xa9, 0x41, 0xf1, 0x8f, 0xc1, 0x36, 0xc0, 0xfd, 0xa9, 0x0c, 0x23, 0xc7, 0xf7,
	0x70, 0xd5, 0x03, 0x7e, 0x87, 0xad, 0x59, 0x12, 0x76, 0x53, 0x7a, 0x93, 0xe3, 0xd8, 0x8e, 0x69,
	0xb2, 0xa6, 0x55, 0x40, 0xb9, 0x60, 0x2b, 0x09, 0x72, 0x92, 0x70, 0xcf, 0x61, 0x7c, 0x87, 0xb5,
	0x29, 0x16, 0x72, 0x54, 0x45, 0x47, 0x59, 0x08, 0x76, 0x80, 0x44, 0x70, 0x51, 0x43, 0x17, 0x29,
	0x80, 0xf6, 0xfe, 0x6c, 0xe6, 0xbf, 0x24, 0xfb, 0xba, 0xb2, 0x4f, 0x21, 0xb4, 0x47, 0x11, 0xec,
	0x1b, 0xca, 0x5e, 0x03, 0xe2, 0x95, 0xc1, 0x36, 0x33, 0x11, 0x9e, 0x04, 0x13, 0x3b, 0x96, 0x57,
	0x6d, 0xc6, 0x1d, 0xb6, 0x76, 0x18, 0xa9, 0x10, 0x26, 0x80, 0x61, 0x58, 0x4d, 0xab, 0x80, 0x42,
	0x66, 0x2a, 0x9f, 0x18, 0x54, 0xd5, 0xd2, 0x22, 0x78, 0x26, 0xfe, 0x9d, 0x1a, 0xe6, 0x93, 0x92,
	0x60, 0xe7, 0x0e, 0x6c, 0x2f, 0xea, 0xd4, 0x11, 0xc5, 0x6f, 0xb1, 0x55, 0xca, 0x2e, 0x10, 0x5d,
	0xb6, 0x42, 0xdb, 0x3e, 0x3b, 0xdc, 0x07, 0xb6, 0xdb, 0x8c, 0x7d, 0xf9, 0xe3, 0x78, 0x36, 0x9f,
	0xc8, 0x13, 0x64, 0x0c, 0x1e, 0x32, 0x88, 0xd8, 0xcd, 0xe9, 0x5f, 0x75, 0x6e, 0xbe, 0x66, 0xb7,
	0xe0, 0x33, 0xd9, 0xa4, 0xe1, 0x0b, 0x39, 0x3e, 0x07, 0x93, 0x2d, 0xd6, 0x80, 0x05, 0x9d, 0x47,
	0x6a, 0xb7, 0x95, 0x04, 0xd9, 0xf9, 0xd8, 0x71, 0x9d, 0xf8, 0xf4, 0xf0, 0x99, 0xce, 0x4e, 0x2d,
	0x8b, 0xbd, 0xec, 0x29, 0xbf, 0xce, 0x93, 0xb8, 0xcf, 0xda, 0xa4, 0x79, 0x3c, 0x73, 0xc6, 0x92,
	0xef, 0xb1, 0x65, 0x55, 0x1e, 0x90, 0x63, 0xbb, 0xc7, 0x75, 0x92, 0xa6, 0x3e, 0x2d, 0xad, 0x22,
	0x56, 0x18, 0xa3, 0xcf, 0x27, 0xbe, 0x27, 0x45, 0xa8, 0xe3, 0x3d, 0x9b, 0xbb, 0x57, 0xed, 0x66,
	0x87, 0x2d, 0x1f, 0xf8, 0xe1, 0xdc, 0x4d, 0xb2, 0x53, 0x8b, 0xb9, 0x43, 0x57, 0xcd, 0x1f, 0x3a,
	0xbe, 0xc9, 0xea, 0x18, 0x22, 0xa6, 0x63, 0xd5, 0x22, 0x41, 0x7c, 0x96, 0x9b, 0x33, 0xc8, 0x9c,
	0x31, 0xe3, 0xaa, 0x33, 0xf6, 0x88, 0x8e, 0x18, 0xac, 0x81, 0x13, 0xc5, 0xce, 0x58, 0x97, 0x82,
	0x53, 0x27, 0x8a, 0xfd, 0x50, 0xf3, 0x25, 0x09, 0x58, 0x0d, 0x43, 0x69, 0xc7, 0x72, 0x70, 0xa1,
	0x17, 0x5b, 0xcb, 0xe2, 0x7c, 0xd1, 0x51, 0x00, 0x54, 0x31, 0x22, 0xf4, 0x53, 0xb5, 0x48, 0xc0,
	0x14, 0xc4, 0x23, 0x80, 0x4e, 0xaa, 0x96, 0x92, 0x40, 0x7b, 0xf4, 0x62, 0xee, 0x9e, 0xa9, 0x94,
	0x25, 0x21, 0x49, 0x4c, 0x8a, 0x96, 0x12, 0xf3, 0x95, 0xc1, 0x58, 0xba, 0x0d, 0x7c, 0x8d, 0x2d,
	0x25, 0x6b, 0xbb, 0x44, 0xab, 0x47, 0x23, 0x6a, 0x61, 0xab, 0x56, 0x22, 0x83, 0xbb, 0xc7, 0xbe,
	0x7f, 0xae, 0x56, 0x15, 0xbf, 0x33, 0xfb, 0x53, 0x2b, 0x96, 0xbe, 0x24, 0xde, 0x7a, 0x3e, 0xde,
	0x74, 0xac, 0x1f, 0xe3, 0xb9, 0xae, 0x5a, 0x89, 0x2c, 0x7e, 0xaf, 0x13, 0x3d, 0x95, 0xa3, 0x45,
	0x7a, 0x97, 0x55, 0xfb, 0x6d, 0xc6, 0x70, 0x81, 0x86, 0xfe, 0xdc, 0x8b, 0xd5, 0x22, 0x64, 0x90,
	0xb4, 0xda, 0x90, 0x02, 0x2d, 0x48, 0x16, 0x02, 0x0f, 0xb8, 0x68, 0xa4, 0x50, 0x27, 0x0f, 0x29,
	0x82, 0xd5, 0xc8, 0xf6, 0x22, 0x1a, 0x26, 0xd6, 0x29, 0xc0, 0x3f, 0x60, 0xab, 0x94, 0x64, 0xba,
	0x74, 0x2c, 0xa3, 0x46, 0x1e, 0x44, 0x2d, 0x9c, 0x52, 0x6b, 0x35, 0x95, 0x56, 0x16, 0xe4, 0x3d,
	0xb6, 0x99, 0x1c, 0x62, 0x85, 0x59, 0xd2, 0x9e, 0x74, 0x5a, 0xa8, 0x5c, 0x3a, 0xc6, 0xf7, 0xd8,
	0x46, 0x6e, 0x2a, 0x34, 0x60, 0x68, 0xb0, 0x38, 0x80, 0xda, 0xd9, 0x29, 0x51, 0xbb, 0xad, 0xb4,
	0x8b, 0x03, 0x50, 0x38, 0xbf, 0xf2, 0x5d, 0x39, 0xb0, 0xc7, 0xe7, 0xd3, 0xd0, 0x9f, 0x7b, 0x93,
	0xce, 0x0a, 0xde, 0x47, 0x05, 0x34, 0xb7, 0xad, 0xab, 0xf9, 0x6d, 0x85, 0x31, 0xaa, 0x81, 0xfd,
	0xb8, 0xb3, 0x46, 0x63, 0x5a, 0xe6, 0x77, 0xd9, 0x7a, 0x31, 0xa6, 0xce, 0x0d, 0xd4, 0x59, 0xc0,
	0xf9, 0x5d, 0x56, 0xc3, 0xd2, 0xbd, 0xbe, 0x63, 0xec, 0xb6, 0x7b, 0x5b, 0x5d, 0xc7, 0xb5, 0x03,
	0x67, 0x6a, 0xc7, 0xf2, 0xa5, 0x7d, 0xd1, 0x9d, 0x43, 0x2e, 0x78, 0xcf, 0x7d, 0x0b, 0x75, 0x30,
	0x95, 0x23, 0x55, 0xb0, 0x37, 0xb0, 0x5e, 0x25, 0xf2, 0xc2, 0x0d, 0xc7, 0x4b, 0x6e, 0xb8, 0xdc,
	0xfd, 0x75, 0xb3, 0x78, 0x7f, 0xe5, 0x6e, 0xa7, 0xcd, 0xe2, 0xed, 0xf4, 0x05, 0x95, 0xff, 0x05,
	0xfe, 0xc5, 0x7c, 0xce, 0x5c, 0x36, 0x74, 0xc9, 0x6b, 0x51, 0x7c, 0xcb, 0x5a, 0x23, 0x7b, 0xda,
	0x9f, 0x4c, 0xa0, 0xaa, 0xbc, 0xc7, 0xaa, 0x23, 0x7b, 0x8a, 0x76, 0xed, 0x5e, 0x5b, 0x97, 0xa3,
	0x91, 0x3d, 0xb5, 0x00, 0xe7, 0x1f, 0xb1, 0x26, 0xcc, 0x36, 0xb2, 0xa7, 0x51, 0x67, 0x09, 0x4b,
	0xd6, 0x8d, 0x6c, 0xc5, 0x05, 0xbd, 0x44, 0x41, 0xdc, 0x4d, 0x1d, 0x07, 0xd7, 0x38, 0x16, 0xa7,
	0xa9, 0xe3, 0x37, 0xe0, 0x30, 0xb2, 0xa7, 0xa0, 0x7d, 0x39, 0x07, 0xad, 0x20, 0xde, 0x47, 0x0e,
	0xd8, 0x95, 0x5c, 0x5a, 0xe2, 0xc5, 0xbd, 0x54, 0x29, 0xe0, 0x7b, 0x99, 0x10, 0xa9, 0x2a, 0xaf,
	0x17, 0xdc, 0x47, 0x99, 0x18, 0x7f, 0x46, 0xae, 0x0b, 0xab, 0x0d, 0x55, 0xd2, 0x9e, 0x26, 0x95,
	0x8d, 0x04, 0xd8, 0x83, 0x91, 0x3d, 0x7d, 0x62, 0xbb, 0xd4, 0xc5, 0xb4, 0x2c, 0x2d, 0xe6, 0x32,
	0xba, 0xb6, 0x98, 0xd1, 0x97, 0x15, 0x38, 0xf1, 0xab, 0x41, 0xb7, 0x74, 0x19, 0x87, 0xdb, 0xac,
	0xa5, 0x86, 0x12, 0x1e, 0x29, 0x90, 0x32, 0xac, 0x66, 0x19, 0x5e, 0x5b, 0x64, 0xfb, 0xba, 0x62,
	0x95, 0xf3, 0x6b, 0x14, 0xf8, 0xfd, 0x66, 0x50, 0xf3, 0x99, 0xa4, 0x67, 0x19, 0x4b, 0xac, 0x9e,
	0xa3, 0x8b, 0x40, 0x6a, 0x96, 0x09, 0xf0, 0x7f, 0xf3, 0x81, 0x8b, 0xe5, 0xc8, 0x0e, 0xcf, 0xb1,
	0x68, 0xb6, 0x2c, 0xfc, 0xce, 0x75, 0x27, 0xcd, 0x42, 0x77, 0xf2, 0xb7, 0xc1, 0x6a, 0xcf, 0xec,
	0x29, 0xb6, 0x88, 0x23, 0x3f, 0xb6, 0x67, 0x96, 0xff, 0x32, 0x52, 0x17, 0x65, 0x0a, 0xc0, 0x28,
	0x68, 0x51, 0xc9, 0x56, 0x41, 0x24, 0x00, 0x4c, 0x00, 0xc2, 0xb1, 0xf3, 0x93, 0x54, 0xab, 0x9d,
	0xc8, 0x70, 0x5d, 0x0c, 0xe7, 0x61, 0x28, 0xbd, 0x18, 0x20, 0x7d, 0x5d, 0x64, 0x20, 0x58, 0x82,
	0xa7, 0xcf, 0x9f, 0x47, 0x52, 0x07, 0xaa, 0xa4, 0xb4, 0xc3, 0x68, 0x64, 0x3a, 0x0c, 0x40, 0x9f,
	0x86, 0x13, 0x19, 0xaa, 0x08, 0x49, 0x80, 0xb0, 0x8f, 0xfd, 0x30, 0xc6, 0xf0, 0x5a, 0x16, 0x7e,
	0xf7, 0xfe, 0x6a, 0xb2, 0xd5, 0x81, 0x1d, 0xc9, 0xfd, 0xc1, 0xb1, 0x0c, 0x7f, 0x80, 0x6e, 0xea,
	0x13, 0xd6, 0xa0, 0xf3, 0xca, 0x37, 0x32, 0x87, 0x8e, 0x0a, 0x83, 0xb9, 0x00, 0x05, 0xa2, 0xa2,
	0x2c, 0x1e, 0xc9, 0x38, 0x67, 0x41, 0xa7, 0xcd, 0x5c, 0x80, 0xc0, 0xe2, 0x73, 0xca, 0x07, 0xba,
	0xe9, 0x61, 0xaa, 0x9b, 0x5a, 0x2b, 0xd3, 0xd7, 0x99, 0x3c, 0x0f, 0x62, 0xbf, 0x56, 0xb0, 0x85,
	0x49, 0x4b, 0xba, 0x3d, 0xb3, 0xcc, 0x9f, 0xa8, 0xf0, 0x21, 0xbb, 0x51, 0x68, 0x33, 0x4b, 0xad,
	0xcd, 0x45, 0x4c, 0xf7, 0xa4, 0xa2, 0xc2, 0x1f, 0xb2, 0xf5, 0x14, 0xdf, 0x97, 0x33, 0x19, 0xcb,
	0xb7, 0xe1, 0xbf, 0x9f, 0xe5, 0x70, 0x74, 0x69, 0x04, 0xef, 0x2e, 0x62, 0xc9, 0x6b, 0x56, 0x54,
	0x78, 0x9f, 0xad, 0xe5, 0xdf, 0x5b, 0x79, 0x27, 0xd4, 0xce, 0x98, 0xef, 0x64, 0xb1, 0xdc, 0xdb,
	0x0c, 0x5d, 0xdc, 0xca, 0xc0, 0x70, 0xf5, 0xd2, 0x15, 0x59, 0xea, 0xa9, 0x04, 0x13, 0x15, 0xfe,
	0x4d, 0xee, 0xd5, 0xa7, 0xcc, 0x6f, 0x97, 0x4c, 0x9a, 0x3c, 0x97, 0xcc, 0xab, 0x46, 0x81, 0xd5,
	0x80, 0x5e, 0x02, 0xd8, 0x1c, 0x1f, 0x84, 0xbe, 0x3b, 0xb4, 0xc7, 0x2f, 0x24, 0xdf, 0xcc, 0x5a,
	0xe9, 0x66, 0xdd, 0x2c, 0x43, 0xc1, 0xc7, 0x03, 0xda, 0x21, 0xa2, 0xf9, 0xd6, 0x41, 0x3d, 0x2c,
	0xb6, 0xc7, 0x97, 0xad, 0x6e, 0xb9, 0xb9, 0xba, 0x8a, 0xb3, 0xcd, 0xca, 0xe4, 0xed, 0x3c, 0x0c,
	0x88, 0x7e, 0x52, 0x2d, 0xc1, 0xfa, 0x56, 0x56, 0x33, 0x19, 0x31, 0xcb, 0x61, 0x51, 0xe1, 0xf7,
	0xa8, 0xec, 0xe3, 0x3b, 0xae, 0xb8, 0x7a, 0xf4, 0x14, 0x34, 0xcb, 0xd0, 0x00, 0x03, 0x58, 0xcb,
	0xff, 0x71, 0x79, 0xd3, 0x33, 0xa2, 0xff, 0xce, 0xf4, 0x7e, 0x31, 0x58, 0x1b, 0x8a, 0x8a, 0x2e,
	0x29, 0x0f, 0xa8, 0xc7, 0xa6, 0x7f, 0x0f, 0xf9, 0x50, 0x92, 0x9f, 0x1a, 0x66, 0x29, 0x0c, 0x7c,
	0x9e, 0xd0, 0x72, 0x64, 0xff, 0x9d, 0xf0, 0xdc, 0xe9, 0x28, 0xfc, 0xba, 0x31, 0xaf, 0x18, 0x0c,
	0x44, 0x65, 0xb0, 0xf2, 0xc7, 0xeb, 0x6d, 0xe3, 0xcf, 0xd7, 0xdb, 0xc6, 0xbf, 0xaf, 0xb7, 0x8d,
	0xb3, 0x06, 0xfe, 0x66, 0xfa, 0xf4, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x42, 0xc5, 0x7e, 0x60,
	0x97, 0x12, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// BaseDBServiceClient is the client API for BaseDBService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type BaseDBServiceClient interface {
	TagAdd(ctx context.Context, in *TagAddReq, opts ...grpc.CallOption) (*TagAddRep, error)
	TagGet(ctx context.Context, in *TagGetReq, opts ...grpc.CallOption) (*TagGetRep, error)
	UserIgnoreAdd(ctx context.Context, in *IgnoreSlice, opts ...grpc.CallOption) (*IgnoreNone, error)
	UserIgnoreGet(ctx context.Context, in *UserIgnore, opts ...grpc.CallOption) (*IgnoreSlice, error)
	UserIgnoreCheck(ctx context.Context, in *UserIgnore, opts ...grpc.CallOption) (*UserIgnoreCheckRep, error)
	UserIgnoreDelete(ctx context.Context, in *IgnoreSlice, opts ...grpc.CallOption) (*IgnoreNone, error)
	UserIgnoreMeGet(ctx context.Context, in *UserIgnore, opts ...grpc.CallOption) (*UserIgnoreMeGetResp, error)
	UserVersionGet(ctx context.Context, in *UserStatus, opts ...grpc.CallOption) (*UserVersionGetRep, error)
	UserVersionReadUpdate(ctx context.Context, in *UserStatus, opts ...grpc.CallOption) (*UserStatus, error)
	UserVersionUpdate(ctx context.Context, in *UserVersionUpdateReq, opts ...grpc.CallOption) (*UserVersionUpdateRep, error)
	UserAlbumFromCache(ctx context.Context, in *UserAlbumReq, opts ...grpc.CallOption) (*UserAlbumRep, error)
	UserStatusUpdate(ctx context.Context, in *UserStatus, opts ...grpc.CallOption) (*UserStatus, error)
	UserStatisticsGet(ctx context.Context, in *UserStatus, opts ...grpc.CallOption) (*UserStatus, error)
	UserHomeBackgroudGet(ctx context.Context, in *UserStatus, opts ...grpc.CallOption) (*UserStatus, error)
	UserRecommendGet(ctx context.Context, in *UserRecommend, opts ...grpc.CallOption) (*UserRecommend, error)
	UserAllID(ctx context.Context, in *UserAllIDReq, opts ...grpc.CallOption) (*UserAllIDRep, error)
	UserIgnoresAll(ctx context.Context, in *UserIgnore, opts ...grpc.CallOption) (*UserIgnoresAllResp, error)
}

type baseDBServiceClient struct {
	cc *grpc.ClientConn
}

func NewBaseDBServiceClient(cc *grpc.ClientConn) BaseDBServiceClient {
	return &baseDBServiceClient{cc}
}

func (c *baseDBServiceClient) TagAdd(ctx context.Context, in *TagAddReq, opts ...grpc.CallOption) (*TagAddRep, error) {
	out := new(TagAddRep)
	err := c.cc.Invoke(ctx, "/moment.BaseDBService/TagAdd", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *baseDBServiceClient) TagGet(ctx context.Context, in *TagGetReq, opts ...grpc.CallOption) (*TagGetRep, error) {
	out := new(TagGetRep)
	err := c.cc.Invoke(ctx, "/moment.BaseDBService/TagGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *baseDBServiceClient) UserIgnoreAdd(ctx context.Context, in *IgnoreSlice, opts ...grpc.CallOption) (*IgnoreNone, error) {
	out := new(IgnoreNone)
	err := c.cc.Invoke(ctx, "/moment.BaseDBService/UserIgnoreAdd", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *baseDBServiceClient) UserIgnoreGet(ctx context.Context, in *UserIgnore, opts ...grpc.CallOption) (*IgnoreSlice, error) {
	out := new(IgnoreSlice)
	err := c.cc.Invoke(ctx, "/moment.BaseDBService/UserIgnoreGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *baseDBServiceClient) UserIgnoreCheck(ctx context.Context, in *UserIgnore, opts ...grpc.CallOption) (*UserIgnoreCheckRep, error) {
	out := new(UserIgnoreCheckRep)
	err := c.cc.Invoke(ctx, "/moment.BaseDBService/UserIgnoreCheck", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *baseDBServiceClient) UserIgnoreDelete(ctx context.Context, in *IgnoreSlice, opts ...grpc.CallOption) (*IgnoreNone, error) {
	out := new(IgnoreNone)
	err := c.cc.Invoke(ctx, "/moment.BaseDBService/UserIgnoreDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *baseDBServiceClient) UserIgnoreMeGet(ctx context.Context, in *UserIgnore, opts ...grpc.CallOption) (*UserIgnoreMeGetResp, error) {
	out := new(UserIgnoreMeGetResp)
	err := c.cc.Invoke(ctx, "/moment.BaseDBService/UserIgnoreMeGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *baseDBServiceClient) UserVersionGet(ctx context.Context, in *UserStatus, opts ...grpc.CallOption) (*UserVersionGetRep, error) {
	out := new(UserVersionGetRep)
	err := c.cc.Invoke(ctx, "/moment.BaseDBService/UserVersionGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *baseDBServiceClient) UserVersionReadUpdate(ctx context.Context, in *UserStatus, opts ...grpc.CallOption) (*UserStatus, error) {
	out := new(UserStatus)
	err := c.cc.Invoke(ctx, "/moment.BaseDBService/UserVersionReadUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *baseDBServiceClient) UserVersionUpdate(ctx context.Context, in *UserVersionUpdateReq, opts ...grpc.CallOption) (*UserVersionUpdateRep, error) {
	out := new(UserVersionUpdateRep)
	err := c.cc.Invoke(ctx, "/moment.BaseDBService/UserVersionUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *baseDBServiceClient) UserAlbumFromCache(ctx context.Context, in *UserAlbumReq, opts ...grpc.CallOption) (*UserAlbumRep, error) {
	out := new(UserAlbumRep)
	err := c.cc.Invoke(ctx, "/moment.BaseDBService/UserAlbumFromCache", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *baseDBServiceClient) UserStatusUpdate(ctx context.Context, in *UserStatus, opts ...grpc.CallOption) (*UserStatus, error) {
	out := new(UserStatus)
	err := c.cc.Invoke(ctx, "/moment.BaseDBService/UserStatusUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *baseDBServiceClient) UserStatisticsGet(ctx context.Context, in *UserStatus, opts ...grpc.CallOption) (*UserStatus, error) {
	out := new(UserStatus)
	err := c.cc.Invoke(ctx, "/moment.BaseDBService/UserStatisticsGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *baseDBServiceClient) UserHomeBackgroudGet(ctx context.Context, in *UserStatus, opts ...grpc.CallOption) (*UserStatus, error) {
	out := new(UserStatus)
	err := c.cc.Invoke(ctx, "/moment.BaseDBService/UserHomeBackgroudGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *baseDBServiceClient) UserRecommendGet(ctx context.Context, in *UserRecommend, opts ...grpc.CallOption) (*UserRecommend, error) {
	out := new(UserRecommend)
	err := c.cc.Invoke(ctx, "/moment.BaseDBService/UserRecommendGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *baseDBServiceClient) UserAllID(ctx context.Context, in *UserAllIDReq, opts ...grpc.CallOption) (*UserAllIDRep, error) {
	out := new(UserAllIDRep)
	err := c.cc.Invoke(ctx, "/moment.BaseDBService/UserAllID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *baseDBServiceClient) UserIgnoresAll(ctx context.Context, in *UserIgnore, opts ...grpc.CallOption) (*UserIgnoresAllResp, error) {
	out := new(UserIgnoresAllResp)
	err := c.cc.Invoke(ctx, "/moment.BaseDBService/UserIgnoresAll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BaseDBServiceServer is the server API for BaseDBService service.
type BaseDBServiceServer interface {
	TagAdd(context.Context, *TagAddReq) (*TagAddRep, error)
	TagGet(context.Context, *TagGetReq) (*TagGetRep, error)
	UserIgnoreAdd(context.Context, *IgnoreSlice) (*IgnoreNone, error)
	UserIgnoreGet(context.Context, *UserIgnore) (*IgnoreSlice, error)
	UserIgnoreCheck(context.Context, *UserIgnore) (*UserIgnoreCheckRep, error)
	UserIgnoreDelete(context.Context, *IgnoreSlice) (*IgnoreNone, error)
	UserIgnoreMeGet(context.Context, *UserIgnore) (*UserIgnoreMeGetResp, error)
	UserVersionGet(context.Context, *UserStatus) (*UserVersionGetRep, error)
	UserVersionReadUpdate(context.Context, *UserStatus) (*UserStatus, error)
	UserVersionUpdate(context.Context, *UserVersionUpdateReq) (*UserVersionUpdateRep, error)
	UserAlbumFromCache(context.Context, *UserAlbumReq) (*UserAlbumRep, error)
	UserStatusUpdate(context.Context, *UserStatus) (*UserStatus, error)
	UserStatisticsGet(context.Context, *UserStatus) (*UserStatus, error)
	UserHomeBackgroudGet(context.Context, *UserStatus) (*UserStatus, error)
	UserRecommendGet(context.Context, *UserRecommend) (*UserRecommend, error)
	UserAllID(context.Context, *UserAllIDReq) (*UserAllIDRep, error)
	UserIgnoresAll(context.Context, *UserIgnore) (*UserIgnoresAllResp, error)
}

// UnimplementedBaseDBServiceServer can be embedded to have forward compatible implementations.
type UnimplementedBaseDBServiceServer struct {
}

func (*UnimplementedBaseDBServiceServer) TagAdd(ctx context.Context, req *TagAddReq) (*TagAddRep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TagAdd not implemented")
}
func (*UnimplementedBaseDBServiceServer) TagGet(ctx context.Context, req *TagGetReq) (*TagGetRep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TagGet not implemented")
}
func (*UnimplementedBaseDBServiceServer) UserIgnoreAdd(ctx context.Context, req *IgnoreSlice) (*IgnoreNone, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserIgnoreAdd not implemented")
}
func (*UnimplementedBaseDBServiceServer) UserIgnoreGet(ctx context.Context, req *UserIgnore) (*IgnoreSlice, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserIgnoreGet not implemented")
}
func (*UnimplementedBaseDBServiceServer) UserIgnoreCheck(ctx context.Context, req *UserIgnore) (*UserIgnoreCheckRep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserIgnoreCheck not implemented")
}
func (*UnimplementedBaseDBServiceServer) UserIgnoreDelete(ctx context.Context, req *IgnoreSlice) (*IgnoreNone, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserIgnoreDelete not implemented")
}
func (*UnimplementedBaseDBServiceServer) UserIgnoreMeGet(ctx context.Context, req *UserIgnore) (*UserIgnoreMeGetResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserIgnoreMeGet not implemented")
}
func (*UnimplementedBaseDBServiceServer) UserVersionGet(ctx context.Context, req *UserStatus) (*UserVersionGetRep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserVersionGet not implemented")
}
func (*UnimplementedBaseDBServiceServer) UserVersionReadUpdate(ctx context.Context, req *UserStatus) (*UserStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserVersionReadUpdate not implemented")
}
func (*UnimplementedBaseDBServiceServer) UserVersionUpdate(ctx context.Context, req *UserVersionUpdateReq) (*UserVersionUpdateRep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserVersionUpdate not implemented")
}
func (*UnimplementedBaseDBServiceServer) UserAlbumFromCache(ctx context.Context, req *UserAlbumReq) (*UserAlbumRep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserAlbumFromCache not implemented")
}
func (*UnimplementedBaseDBServiceServer) UserStatusUpdate(ctx context.Context, req *UserStatus) (*UserStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserStatusUpdate not implemented")
}
func (*UnimplementedBaseDBServiceServer) UserStatisticsGet(ctx context.Context, req *UserStatus) (*UserStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserStatisticsGet not implemented")
}
func (*UnimplementedBaseDBServiceServer) UserHomeBackgroudGet(ctx context.Context, req *UserStatus) (*UserStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserHomeBackgroudGet not implemented")
}
func (*UnimplementedBaseDBServiceServer) UserRecommendGet(ctx context.Context, req *UserRecommend) (*UserRecommend, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserRecommendGet not implemented")
}
func (*UnimplementedBaseDBServiceServer) UserAllID(ctx context.Context, req *UserAllIDReq) (*UserAllIDRep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserAllID not implemented")
}
func (*UnimplementedBaseDBServiceServer) UserIgnoresAll(ctx context.Context, req *UserIgnore) (*UserIgnoresAllResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserIgnoresAll not implemented")
}

func RegisterBaseDBServiceServer(s *grpc.Server, srv BaseDBServiceServer) {
	s.RegisterService(&_BaseDBService_serviceDesc, srv)
}

func _BaseDBService_TagAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TagAddReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseDBServiceServer).TagAdd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.BaseDBService/TagAdd",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseDBServiceServer).TagAdd(ctx, req.(*TagAddReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BaseDBService_TagGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TagGetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseDBServiceServer).TagGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.BaseDBService/TagGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseDBServiceServer).TagGet(ctx, req.(*TagGetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BaseDBService_UserIgnoreAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IgnoreSlice)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseDBServiceServer).UserIgnoreAdd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.BaseDBService/UserIgnoreAdd",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseDBServiceServer).UserIgnoreAdd(ctx, req.(*IgnoreSlice))
	}
	return interceptor(ctx, in, info, handler)
}

func _BaseDBService_UserIgnoreGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserIgnore)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseDBServiceServer).UserIgnoreGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.BaseDBService/UserIgnoreGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseDBServiceServer).UserIgnoreGet(ctx, req.(*UserIgnore))
	}
	return interceptor(ctx, in, info, handler)
}

func _BaseDBService_UserIgnoreCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserIgnore)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseDBServiceServer).UserIgnoreCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.BaseDBService/UserIgnoreCheck",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseDBServiceServer).UserIgnoreCheck(ctx, req.(*UserIgnore))
	}
	return interceptor(ctx, in, info, handler)
}

func _BaseDBService_UserIgnoreDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IgnoreSlice)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseDBServiceServer).UserIgnoreDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.BaseDBService/UserIgnoreDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseDBServiceServer).UserIgnoreDelete(ctx, req.(*IgnoreSlice))
	}
	return interceptor(ctx, in, info, handler)
}

func _BaseDBService_UserIgnoreMeGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserIgnore)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseDBServiceServer).UserIgnoreMeGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.BaseDBService/UserIgnoreMeGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseDBServiceServer).UserIgnoreMeGet(ctx, req.(*UserIgnore))
	}
	return interceptor(ctx, in, info, handler)
}

func _BaseDBService_UserVersionGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseDBServiceServer).UserVersionGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.BaseDBService/UserVersionGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseDBServiceServer).UserVersionGet(ctx, req.(*UserStatus))
	}
	return interceptor(ctx, in, info, handler)
}

func _BaseDBService_UserVersionReadUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseDBServiceServer).UserVersionReadUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.BaseDBService/UserVersionReadUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseDBServiceServer).UserVersionReadUpdate(ctx, req.(*UserStatus))
	}
	return interceptor(ctx, in, info, handler)
}

func _BaseDBService_UserVersionUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserVersionUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseDBServiceServer).UserVersionUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.BaseDBService/UserVersionUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseDBServiceServer).UserVersionUpdate(ctx, req.(*UserVersionUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BaseDBService_UserAlbumFromCache_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserAlbumReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseDBServiceServer).UserAlbumFromCache(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.BaseDBService/UserAlbumFromCache",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseDBServiceServer).UserAlbumFromCache(ctx, req.(*UserAlbumReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BaseDBService_UserStatusUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseDBServiceServer).UserStatusUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.BaseDBService/UserStatusUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseDBServiceServer).UserStatusUpdate(ctx, req.(*UserStatus))
	}
	return interceptor(ctx, in, info, handler)
}

func _BaseDBService_UserStatisticsGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseDBServiceServer).UserStatisticsGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.BaseDBService/UserStatisticsGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseDBServiceServer).UserStatisticsGet(ctx, req.(*UserStatus))
	}
	return interceptor(ctx, in, info, handler)
}

func _BaseDBService_UserHomeBackgroudGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseDBServiceServer).UserHomeBackgroudGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.BaseDBService/UserHomeBackgroudGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseDBServiceServer).UserHomeBackgroudGet(ctx, req.(*UserStatus))
	}
	return interceptor(ctx, in, info, handler)
}

func _BaseDBService_UserRecommendGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRecommend)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseDBServiceServer).UserRecommendGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.BaseDBService/UserRecommendGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseDBServiceServer).UserRecommendGet(ctx, req.(*UserRecommend))
	}
	return interceptor(ctx, in, info, handler)
}

func _BaseDBService_UserAllID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserAllIDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseDBServiceServer).UserAllID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.BaseDBService/UserAllID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseDBServiceServer).UserAllID(ctx, req.(*UserAllIDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BaseDBService_UserIgnoresAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserIgnore)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseDBServiceServer).UserIgnoresAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.BaseDBService/UserIgnoresAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseDBServiceServer).UserIgnoresAll(ctx, req.(*UserIgnore))
	}
	return interceptor(ctx, in, info, handler)
}

var _BaseDBService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "moment.BaseDBService",
	HandlerType: (*BaseDBServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "TagAdd",
			Handler:    _BaseDBService_TagAdd_Handler,
		},
		{
			MethodName: "TagGet",
			Handler:    _BaseDBService_TagGet_Handler,
		},
		{
			MethodName: "UserIgnoreAdd",
			Handler:    _BaseDBService_UserIgnoreAdd_Handler,
		},
		{
			MethodName: "UserIgnoreGet",
			Handler:    _BaseDBService_UserIgnoreGet_Handler,
		},
		{
			MethodName: "UserIgnoreCheck",
			Handler:    _BaseDBService_UserIgnoreCheck_Handler,
		},
		{
			MethodName: "UserIgnoreDelete",
			Handler:    _BaseDBService_UserIgnoreDelete_Handler,
		},
		{
			MethodName: "UserIgnoreMeGet",
			Handler:    _BaseDBService_UserIgnoreMeGet_Handler,
		},
		{
			MethodName: "UserVersionGet",
			Handler:    _BaseDBService_UserVersionGet_Handler,
		},
		{
			MethodName: "UserVersionReadUpdate",
			Handler:    _BaseDBService_UserVersionReadUpdate_Handler,
		},
		{
			MethodName: "UserVersionUpdate",
			Handler:    _BaseDBService_UserVersionUpdate_Handler,
		},
		{
			MethodName: "UserAlbumFromCache",
			Handler:    _BaseDBService_UserAlbumFromCache_Handler,
		},
		{
			MethodName: "UserStatusUpdate",
			Handler:    _BaseDBService_UserStatusUpdate_Handler,
		},
		{
			MethodName: "UserStatisticsGet",
			Handler:    _BaseDBService_UserStatisticsGet_Handler,
		},
		{
			MethodName: "UserHomeBackgroudGet",
			Handler:    _BaseDBService_UserHomeBackgroudGet_Handler,
		},
		{
			MethodName: "UserRecommendGet",
			Handler:    _BaseDBService_UserRecommendGet_Handler,
		},
		{
			MethodName: "UserAllID",
			Handler:    _BaseDBService_UserAllID_Handler,
		},
		{
			MethodName: "UserIgnoresAll",
			Handler:    _BaseDBService_UserIgnoresAll_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "base.proto",
}

// BaseServiceClient is the client API for BaseService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type BaseServiceClient interface {
	UserAlbums(ctx context.Context, in *UserAlbumsReq, opts ...grpc.CallOption) (*UserAlbumsRep, error)
	UserContactsSync(ctx context.Context, in *UserContactsSyncReq, opts ...grpc.CallOption) (*UserContactsSyncRep, error)
}

type baseServiceClient struct {
	cc *grpc.ClientConn
}

func NewBaseServiceClient(cc *grpc.ClientConn) BaseServiceClient {
	return &baseServiceClient{cc}
}

func (c *baseServiceClient) UserAlbums(ctx context.Context, in *UserAlbumsReq, opts ...grpc.CallOption) (*UserAlbumsRep, error) {
	out := new(UserAlbumsRep)
	err := c.cc.Invoke(ctx, "/moment.BaseService/UserAlbums", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *baseServiceClient) UserContactsSync(ctx context.Context, in *UserContactsSyncReq, opts ...grpc.CallOption) (*UserContactsSyncRep, error) {
	out := new(UserContactsSyncRep)
	err := c.cc.Invoke(ctx, "/moment.BaseService/UserContactsSync", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BaseServiceServer is the server API for BaseService service.
type BaseServiceServer interface {
	UserAlbums(context.Context, *UserAlbumsReq) (*UserAlbumsRep, error)
	UserContactsSync(context.Context, *UserContactsSyncReq) (*UserContactsSyncRep, error)
}

// UnimplementedBaseServiceServer can be embedded to have forward compatible implementations.
type UnimplementedBaseServiceServer struct {
}

func (*UnimplementedBaseServiceServer) UserAlbums(ctx context.Context, req *UserAlbumsReq) (*UserAlbumsRep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserAlbums not implemented")
}
func (*UnimplementedBaseServiceServer) UserContactsSync(ctx context.Context, req *UserContactsSyncReq) (*UserContactsSyncRep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserContactsSync not implemented")
}

func RegisterBaseServiceServer(s *grpc.Server, srv BaseServiceServer) {
	s.RegisterService(&_BaseService_serviceDesc, srv)
}

func _BaseService_UserAlbums_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserAlbumsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseServiceServer).UserAlbums(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.BaseService/UserAlbums",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseServiceServer).UserAlbums(ctx, req.(*UserAlbumsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BaseService_UserContactsSync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserContactsSyncReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseServiceServer).UserContactsSync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.BaseService/UserContactsSync",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseServiceServer).UserContactsSync(ctx, req.(*UserContactsSyncReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _BaseService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "moment.BaseService",
	HandlerType: (*BaseServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UserAlbums",
			Handler:    _BaseService_UserAlbums_Handler,
		},
		{
			MethodName: "UserContactsSync",
			Handler:    _BaseService_UserContactsSync_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "base.proto",
}

func (m *UserIgnoresAllResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserIgnoresAllResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserIgnoresAllResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UserIDs) > 0 {
		dAtA2 := make([]byte, len(m.UserIDs)*10)
		var j1 int
		for _, num1 := range m.UserIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintBase(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserIgnoreMeGetResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserIgnoreMeGetResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserIgnoreMeGetResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UserIDs) > 0 {
		dAtA4 := make([]byte, len(m.UserIDs)*10)
		var j3 int
		for _, num1 := range m.UserIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintBase(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserContactsSyncReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserContactsSyncReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserContactsSyncReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ContactID) > 0 {
		dAtA6 := make([]byte, len(m.ContactID)*10)
		var j5 int
		for _, num1 := range m.ContactID {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintBase(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0x1a
	}
	if m.UserID != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x10
	}
	if m.Action != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.Action))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserContactsSyncRep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserContactsSyncRep) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserContactsSyncRep) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintBase(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserAlbumsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserAlbumsReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserAlbumsReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.FriendID != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.FriendID))
		i--
		dAtA[i] = 0x10
	}
	if m.UserID != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserAlbumsRep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserAlbumsRep) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserAlbumsRep) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Medias) > 0 {
		for iNdEx := len(m.Medias) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Medias[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBase(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintBase(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserVersionGetRep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserVersionGetRep) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserVersionGetRep) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.FollowUID != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.FollowUID))
		i--
		dAtA[i] = 0x30
	}
	if m.FollowState {
		i--
		if m.FollowState {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.FriendUID != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.FriendUID))
		i--
		dAtA[i] = 0x20
	}
	if m.FriendState {
		i--
		if m.FriendState {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.RecommendUID != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.RecommendUID))
		i--
		dAtA[i] = 0x10
	}
	if m.RecommendState {
		i--
		if m.RecommendState {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserVersionUpdateReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserVersionUpdateReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserVersionUpdateReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Fans) > 0 {
		dAtA8 := make([]byte, len(m.Fans)*10)
		var j7 int
		for _, num1 := range m.Fans {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		i -= j7
		copy(dAtA[i:], dAtA8[:j7])
		i = encodeVarintBase(dAtA, i, uint64(j7))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Friend) > 0 {
		dAtA10 := make([]byte, len(m.Friend)*10)
		var j9 int
		for _, num1 := range m.Friend {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		i -= j9
		copy(dAtA[i:], dAtA10[:j9])
		i = encodeVarintBase(dAtA, i, uint64(j9))
		i--
		dAtA[i] = 0x22
	}
	if m.Version != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x18
	}
	if m.IsRecommedUser {
		i--
		if m.IsRecommedUser {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.UserID != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserVersionUpdateRep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserVersionUpdateRep) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserVersionUpdateRep) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *UserAllIDReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserAllIDReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserAllIDReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ExcludeUID) > 0 {
		dAtA12 := make([]byte, len(m.ExcludeUID)*10)
		var j11 int
		for _, num1 := range m.ExcludeUID {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		i -= j11
		copy(dAtA[i:], dAtA12[:j11])
		i = encodeVarintBase(dAtA, i, uint64(j11))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserAllIDRep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserAllIDRep) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserAllIDRep) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UserIDs) > 0 {
		dAtA14 := make([]byte, len(m.UserIDs)*10)
		var j13 int
		for _, num1 := range m.UserIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		i -= j13
		copy(dAtA[i:], dAtA14[:j13])
		i = encodeVarintBase(dAtA, i, uint64(j13))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserRecommendCheckRep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserRecommendCheckRep) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserRecommendCheckRep) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LimitVIP != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.LimitVIP))
		i--
		dAtA[i] = 0x10
	}
	if m.Status {
		i--
		if m.Status {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserIgnoreCheckRep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserIgnoreCheckRep) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserIgnoreCheckRep) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status {
		i--
		if m.Status {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IgnoreSlice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IgnoreSlice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IgnoreSlice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Ignores) > 0 {
		for iNdEx := len(m.Ignores) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ignores[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBase(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *IgnoreNone) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IgnoreNone) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IgnoreNone) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *UserAlbumReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserAlbumReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserAlbumReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Limit != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x20
	}
	if m.FriendID != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.FriendID))
		i--
		dAtA[i] = 0x18
	}
	if m.ForumID != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.ForumID))
		i--
		dAtA[i] = 0x10
	}
	if m.UserID != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserAlbumRep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserAlbumRep) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserAlbumRep) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Medias) > 0 {
		for iNdEx := len(m.Medias) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Medias[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBase(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UserStatisticsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserStatisticsReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserStatisticsReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CreateBy != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.CreateBy))
		i--
		dAtA[i] = 0x10
	}
	if m.Vistor != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.Vistor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserStatisticsRep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserStatisticsRep) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserStatisticsRep) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Fans != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.Fans))
		i--
		dAtA[i] = 0x20
	}
	if m.Thumb != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.Thumb))
		i--
		dAtA[i] = 0x18
	}
	if m.Follow != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.Follow))
		i--
		dAtA[i] = 0x10
	}
	if m.Forum != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.Forum))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserIgnore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserIgnore) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserIgnore) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CreateAt != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.CreateAt))
		i--
		dAtA[i] = 0x30
	}
	if m.CreateBy != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.CreateBy))
		i--
		dAtA[i] = 0x28
	}
	if m.UserID != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x20
	}
	if m.Look != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.Look))
		i--
		dAtA[i] = 0x18
	}
	if m.IgnoreID != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.IgnoreID))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.FollowUID != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.FollowUID))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.FriendUID != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.FriendUID))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.RecommendUID != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.RecommendUID))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.IsFriend {
		i--
		if m.IsFriend {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.User != nil {
		{
			size, err := m.User.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBase(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.RecommendVersion != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.RecommendVersion))
		i--
		dAtA[i] = 0x78
	}
	if m.UpdateAt != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.UpdateAt))
		i--
		dAtA[i] = 0x70
	}
	if m.CreateAt != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.CreateAt))
		i--
		dAtA[i] = 0x68
	}
	if len(m.HomeBackground) > 0 {
		i -= len(m.HomeBackground)
		copy(dAtA[i:], m.HomeBackground)
		i = encodeVarintBase(dAtA, i, uint64(len(m.HomeBackground)))
		i--
		dAtA[i] = 0x62
	}
	if m.FollowVersionRead != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.FollowVersionRead))
		i--
		dAtA[i] = 0x58
	}
	if m.FriendVersionRead != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.FriendVersionRead))
		i--
		dAtA[i] = 0x50
	}
	if m.RecommendVersionRead != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.RecommendVersionRead))
		i--
		dAtA[i] = 0x48
	}
	if m.FollowVersion != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.FollowVersion))
		i--
		dAtA[i] = 0x40
	}
	if m.FriendVersion != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.FriendVersion))
		i--
		dAtA[i] = 0x38
	}
	if m.FansCount != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.FansCount))
		i--
		dAtA[i] = 0x30
	}
	if m.ThumbCount != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.ThumbCount))
		i--
		dAtA[i] = 0x28
	}
	if m.FollowCount != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.FollowCount))
		i--
		dAtA[i] = 0x20
	}
	if m.ForumCount != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.ForumCount))
		i--
		dAtA[i] = 0x18
	}
	if m.UserID != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserRecommendVersion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserRecommendVersion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserRecommendVersion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintBase(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x12
	}
	if m.ID != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TagAddReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TagAddReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TagAddReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UserTags) > 0 {
		for iNdEx := len(m.UserTags) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UserTags[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBase(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Tag != nil {
		{
			size, err := m.Tag.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBase(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TagAddRep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TagAddRep) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TagAddRep) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Tag != nil {
		{
			size, err := m.Tag.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBase(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserTags) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserTags) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserTags) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TagUsers) > 0 {
		for iNdEx := len(m.TagUsers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TagUsers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBase(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Tag != nil {
		{
			size, err := m.Tag.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBase(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TagGetReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TagGetReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TagGetReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserID != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TagGetRep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TagGetRep) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TagGetRep) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UserTags) > 0 {
		for iNdEx := len(m.UserTags) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UserTags[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBase(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Tag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tag) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tag) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CreateBy != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.CreateBy))
		i--
		dAtA[i] = 0x28
	}
	if m.CreateAt != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.CreateAt))
		i--
		dAtA[i] = 0x20
	}
	if len(m.TagName) > 0 {
		i -= len(m.TagName)
		copy(dAtA[i:], m.TagName)
		i = encodeVarintBase(dAtA, i, uint64(len(m.TagName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.TagID != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.TagID))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserTag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserTag) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserTag) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CreateBy != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.CreateBy))
		i--
		dAtA[i] = 0x30
	}
	if m.CreateAt != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.CreateAt))
		i--
		dAtA[i] = 0x28
	}
	if m.UserID != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x20
	}
	if m.TagID != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.TagID))
		i--
		dAtA[i] = 0x18
	}
	if m.UserTagID != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.UserTagID))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserRecommend) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserRecommend) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserRecommend) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LimitVIP != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.LimitVIP))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Mark) > 0 {
		i -= len(m.Mark)
		copy(dAtA[i:], m.Mark)
		i = encodeVarintBase(dAtA, i, uint64(len(m.Mark)))
		i--
		dAtA[i] = 0x3a
	}
	if m.CreateBy != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.CreateBy))
		i--
		dAtA[i] = 0x30
	}
	if m.CreateAt != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.CreateAt))
		i--
		dAtA[i] = 0x28
	}
	if m.UserID != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x20
	}
	if m.ForumType != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.ForumType))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Page) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Page) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Page) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Sort) > 0 {
		i -= len(m.Sort)
		copy(dAtA[i:], m.Sort)
		i = encodeVarintBase(dAtA, i, uint64(len(m.Sort)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Order) > 0 {
		i -= len(m.Order)
		copy(dAtA[i:], m.Order)
		i = encodeVarintBase(dAtA, i, uint64(len(m.Order)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Limit != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x30
	}
	if m.Offset != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x28
	}
	if m.CurrentPage != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.CurrentPage))
		i--
		dAtA[i] = 0x20
	}
	if m.PageSize != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.PageSize))
		i--
		dAtA[i] = 0x18
	}
	if m.PageCount != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.PageCount))
		i--
		dAtA[i] = 0x10
	}
	if m.TotalRows != 0 {
		i = encodeVarintBase(dAtA, i, uint64(m.TotalRows))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintBase(dAtA []byte, offset int, v uint64) int {
	offset -= sovBase(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *UserIgnoresAllResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.UserIDs) > 0 {
		l = 0
		for _, e := range m.UserIDs {
			l += sovBase(uint64(e))
		}
		n += 1 + sovBase(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserIgnoreMeGetResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.UserIDs) > 0 {
		l = 0
		for _, e := range m.UserIDs {
			l += sovBase(uint64(e))
		}
		n += 1 + sovBase(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserContactsSyncReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Action != 0 {
		n += 1 + sovBase(uint64(m.Action))
	}
	if m.UserID != 0 {
		n += 1 + sovBase(uint64(m.UserID))
	}
	if len(m.ContactID) > 0 {
		l = 0
		for _, e := range m.ContactID {
			l += sovBase(uint64(e))
		}
		n += 1 + sovBase(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserContactsSyncRep) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovBase(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserAlbumsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovBase(uint64(m.UserID))
	}
	if m.FriendID != 0 {
		n += 1 + sovBase(uint64(m.FriendID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserAlbumsRep) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovBase(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	if len(m.Medias) > 0 {
		for _, e := range m.Medias {
			l = e.Size()
			n += 1 + l + sovBase(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserVersionGetRep) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RecommendState {
		n += 2
	}
	if m.RecommendUID != 0 {
		n += 1 + sovBase(uint64(m.RecommendUID))
	}
	if m.FriendState {
		n += 2
	}
	if m.FriendUID != 0 {
		n += 1 + sovBase(uint64(m.FriendUID))
	}
	if m.FollowState {
		n += 2
	}
	if m.FollowUID != 0 {
		n += 1 + sovBase(uint64(m.FollowUID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserVersionUpdateReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovBase(uint64(m.UserID))
	}
	if m.IsRecommedUser {
		n += 2
	}
	if m.Version != 0 {
		n += 1 + sovBase(uint64(m.Version))
	}
	if len(m.Friend) > 0 {
		l = 0
		for _, e := range m.Friend {
			l += sovBase(uint64(e))
		}
		n += 1 + sovBase(uint64(l)) + l
	}
	if len(m.Fans) > 0 {
		l = 0
		for _, e := range m.Fans {
			l += sovBase(uint64(e))
		}
		n += 1 + sovBase(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserVersionUpdateRep) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserAllIDReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ExcludeUID) > 0 {
		l = 0
		for _, e := range m.ExcludeUID {
			l += sovBase(uint64(e))
		}
		n += 1 + sovBase(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserAllIDRep) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.UserIDs) > 0 {
		l = 0
		for _, e := range m.UserIDs {
			l += sovBase(uint64(e))
		}
		n += 1 + sovBase(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserRecommendCheckRep) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status {
		n += 2
	}
	if m.LimitVIP != 0 {
		n += 1 + sovBase(uint64(m.LimitVIP))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserIgnoreCheckRep) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IgnoreSlice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ignores) > 0 {
		for _, e := range m.Ignores {
			l = e.Size()
			n += 1 + l + sovBase(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IgnoreNone) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserAlbumReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovBase(uint64(m.UserID))
	}
	if m.ForumID != 0 {
		n += 1 + sovBase(uint64(m.ForumID))
	}
	if m.FriendID != 0 {
		n += 1 + sovBase(uint64(m.FriendID))
	}
	if m.Limit != 0 {
		n += 1 + sovBase(uint64(m.Limit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserAlbumRep) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Medias) > 0 {
		for _, e := range m.Medias {
			l = e.Size()
			n += 1 + l + sovBase(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserStatisticsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Vistor != 0 {
		n += 1 + sovBase(uint64(m.Vistor))
	}
	if m.CreateBy != 0 {
		n += 1 + sovBase(uint64(m.CreateBy))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserStatisticsRep) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Forum != 0 {
		n += 1 + sovBase(uint64(m.Forum))
	}
	if m.Follow != 0 {
		n += 1 + sovBase(uint64(m.Follow))
	}
	if m.Thumb != 0 {
		n += 1 + sovBase(uint64(m.Thumb))
	}
	if m.Fans != 0 {
		n += 1 + sovBase(uint64(m.Fans))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserIgnore) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovBase(uint64(m.ID))
	}
	if m.IgnoreID != 0 {
		n += 1 + sovBase(uint64(m.IgnoreID))
	}
	if m.Look != 0 {
		n += 1 + sovBase(uint64(m.Look))
	}
	if m.UserID != 0 {
		n += 1 + sovBase(uint64(m.UserID))
	}
	if m.CreateBy != 0 {
		n += 1 + sovBase(uint64(m.CreateBy))
	}
	if m.CreateAt != 0 {
		n += 1 + sovBase(uint64(m.CreateAt))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovBase(uint64(m.ID))
	}
	if m.UserID != 0 {
		n += 1 + sovBase(uint64(m.UserID))
	}
	if m.ForumCount != 0 {
		n += 1 + sovBase(uint64(m.ForumCount))
	}
	if m.FollowCount != 0 {
		n += 1 + sovBase(uint64(m.FollowCount))
	}
	if m.ThumbCount != 0 {
		n += 1 + sovBase(uint64(m.ThumbCount))
	}
	if m.FansCount != 0 {
		n += 1 + sovBase(uint64(m.FansCount))
	}
	if m.FriendVersion != 0 {
		n += 1 + sovBase(uint64(m.FriendVersion))
	}
	if m.FollowVersion != 0 {
		n += 1 + sovBase(uint64(m.FollowVersion))
	}
	if m.RecommendVersionRead != 0 {
		n += 1 + sovBase(uint64(m.RecommendVersionRead))
	}
	if m.FriendVersionRead != 0 {
		n += 1 + sovBase(uint64(m.FriendVersionRead))
	}
	if m.FollowVersionRead != 0 {
		n += 1 + sovBase(uint64(m.FollowVersionRead))
	}
	l = len(m.HomeBackground)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	if m.CreateAt != 0 {
		n += 1 + sovBase(uint64(m.CreateAt))
	}
	if m.UpdateAt != 0 {
		n += 1 + sovBase(uint64(m.UpdateAt))
	}
	if m.RecommendVersion != 0 {
		n += 1 + sovBase(uint64(m.RecommendVersion))
	}
	if m.User != nil {
		l = m.User.Size()
		n += 2 + l + sovBase(uint64(l))
	}
	if m.IsFriend {
		n += 3
	}
	if m.RecommendUID != 0 {
		n += 2 + sovBase(uint64(m.RecommendUID))
	}
	if m.FriendUID != 0 {
		n += 2 + sovBase(uint64(m.FriendUID))
	}
	if m.FollowUID != 0 {
		n += 2 + sovBase(uint64(m.FollowUID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserRecommendVersion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovBase(uint64(m.ID))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TagAddReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tag != nil {
		l = m.Tag.Size()
		n += 1 + l + sovBase(uint64(l))
	}
	if len(m.UserTags) > 0 {
		for _, e := range m.UserTags {
			l = e.Size()
			n += 1 + l + sovBase(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TagAddRep) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tag != nil {
		l = m.Tag.Size()
		n += 1 + l + sovBase(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserTags) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tag != nil {
		l = m.Tag.Size()
		n += 1 + l + sovBase(uint64(l))
	}
	if len(m.TagUsers) > 0 {
		for _, e := range m.TagUsers {
			l = e.Size()
			n += 1 + l + sovBase(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TagGetReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovBase(uint64(m.UserID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TagGetRep) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.UserTags) > 0 {
		for _, e := range m.UserTags {
			l = e.Size()
			n += 1 + l + sovBase(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Tag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovBase(uint64(m.ID))
	}
	if m.TagID != 0 {
		n += 1 + sovBase(uint64(m.TagID))
	}
	l = len(m.TagName)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	if m.CreateAt != 0 {
		n += 1 + sovBase(uint64(m.CreateAt))
	}
	if m.CreateBy != 0 {
		n += 1 + sovBase(uint64(m.CreateBy))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserTag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovBase(uint64(m.ID))
	}
	if m.UserTagID != 0 {
		n += 1 + sovBase(uint64(m.UserTagID))
	}
	if m.TagID != 0 {
		n += 1 + sovBase(uint64(m.TagID))
	}
	if m.UserID != 0 {
		n += 1 + sovBase(uint64(m.UserID))
	}
	if m.CreateAt != 0 {
		n += 1 + sovBase(uint64(m.CreateAt))
	}
	if m.CreateBy != 0 {
		n += 1 + sovBase(uint64(m.CreateBy))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserRecommend) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovBase(uint64(m.ID))
	}
	if m.ForumType != 0 {
		n += 1 + sovBase(uint64(m.ForumType))
	}
	if m.UserID != 0 {
		n += 1 + sovBase(uint64(m.UserID))
	}
	if m.CreateAt != 0 {
		n += 1 + sovBase(uint64(m.CreateAt))
	}
	if m.CreateBy != 0 {
		n += 1 + sovBase(uint64(m.CreateBy))
	}
	l = len(m.Mark)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	if m.LimitVIP != 0 {
		n += 1 + sovBase(uint64(m.LimitVIP))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Page) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TotalRows != 0 {
		n += 1 + sovBase(uint64(m.TotalRows))
	}
	if m.PageCount != 0 {
		n += 1 + sovBase(uint64(m.PageCount))
	}
	if m.PageSize != 0 {
		n += 1 + sovBase(uint64(m.PageSize))
	}
	if m.CurrentPage != 0 {
		n += 1 + sovBase(uint64(m.CurrentPage))
	}
	if m.Offset != 0 {
		n += 1 + sovBase(uint64(m.Offset))
	}
	if m.Limit != 0 {
		n += 1 + sovBase(uint64(m.Limit))
	}
	l = len(m.Order)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	l = len(m.Sort)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovBase(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBase(x uint64) (n int) {
	return sovBase(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *UserIgnoresAllResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserIgnoresAllResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserIgnoresAllResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UserIDs = append(m.UserIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBase
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthBase
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UserIDs) == 0 {
					m.UserIDs = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UserIDs = append(m.UserIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserIgnoreMeGetResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserIgnoreMeGetResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserIgnoreMeGetResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UserIDs = append(m.UserIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBase
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthBase
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UserIDs) == 0 {
					m.UserIDs = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UserIDs = append(m.UserIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserContactsSyncReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserContactsSyncReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserContactsSyncReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ContactID = append(m.ContactID, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBase
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthBase
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ContactID) == 0 {
					m.ContactID = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ContactID = append(m.ContactID, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ContactID", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserContactsSyncRep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserContactsSyncRep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserContactsSyncRep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBase
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserAlbumsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserAlbumsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserAlbumsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FriendID", wireType)
			}
			m.FriendID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FriendID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserAlbumsRep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserAlbumsRep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserAlbumsRep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBase
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Medias", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBase
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Medias = append(m.Medias, &Media{})
			if err := m.Medias[len(m.Medias)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserVersionGetRep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserVersionGetRep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserVersionGetRep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecommendState", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RecommendState = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecommendUID", wireType)
			}
			m.RecommendUID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecommendUID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FriendState", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FriendState = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FriendUID", wireType)
			}
			m.FriendUID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FriendUID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FollowState", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FollowState = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FollowUID", wireType)
			}
			m.FollowUID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FollowUID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserVersionUpdateReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserVersionUpdateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserVersionUpdateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRecommedUser", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRecommedUser = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Friend = append(m.Friend, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBase
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthBase
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Friend) == 0 {
					m.Friend = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Friend = append(m.Friend, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Friend", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Fans = append(m.Fans, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBase
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthBase
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Fans) == 0 {
					m.Fans = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Fans = append(m.Fans, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Fans", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserVersionUpdateRep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserVersionUpdateRep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserVersionUpdateRep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserAllIDReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserAllIDReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserAllIDReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ExcludeUID = append(m.ExcludeUID, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBase
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthBase
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ExcludeUID) == 0 {
					m.ExcludeUID = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ExcludeUID = append(m.ExcludeUID, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludeUID", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserAllIDRep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserAllIDRep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserAllIDRep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UserIDs = append(m.UserIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBase
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthBase
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UserIDs) == 0 {
					m.UserIDs = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UserIDs = append(m.UserIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserRecommendCheckRep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserRecommendCheckRep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserRecommendCheckRep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitVIP", wireType)
			}
			m.LimitVIP = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitVIP |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserIgnoreCheckRep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserIgnoreCheckRep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserIgnoreCheckRep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IgnoreSlice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IgnoreSlice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IgnoreSlice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ignores", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBase
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ignores = append(m.Ignores, &UserIgnore{})
			if err := m.Ignores[len(m.Ignores)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IgnoreNone) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IgnoreNone: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IgnoreNone: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserAlbumReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserAlbumReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserAlbumReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForumID", wireType)
			}
			m.ForumID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForumID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FriendID", wireType)
			}
			m.FriendID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FriendID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserAlbumRep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserAlbumRep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserAlbumRep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Medias", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBase
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Medias = append(m.Medias, &Media{})
			if err := m.Medias[len(m.Medias)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserStatisticsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserStatisticsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserStatisticsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vistor", wireType)
			}
			m.Vistor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vistor |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateBy", wireType)
			}
			m.CreateBy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateBy |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserStatisticsRep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserStatisticsRep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserStatisticsRep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Forum", wireType)
			}
			m.Forum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Forum |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Follow", wireType)
			}
			m.Follow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Follow |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumb", wireType)
			}
			m.Thumb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Thumb |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fans", wireType)
			}
			m.Fans = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fans |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserIgnore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserIgnore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserIgnore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreID", wireType)
			}
			m.IgnoreID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IgnoreID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Look", wireType)
			}
			m.Look = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Look |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateBy", wireType)
			}
			m.CreateBy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateBy |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForumCount", wireType)
			}
			m.ForumCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForumCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FollowCount", wireType)
			}
			m.FollowCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FollowCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThumbCount", wireType)
			}
			m.ThumbCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ThumbCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FansCount", wireType)
			}
			m.FansCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FansCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FriendVersion", wireType)
			}
			m.FriendVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FriendVersion |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FollowVersion", wireType)
			}
			m.FollowVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FollowVersion |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecommendVersionRead", wireType)
			}
			m.RecommendVersionRead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecommendVersionRead |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FriendVersionRead", wireType)
			}
			m.FriendVersionRead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FriendVersionRead |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FollowVersionRead", wireType)
			}
			m.FollowVersionRead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FollowVersionRead |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomeBackground", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBase
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HomeBackground = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateAt", wireType)
			}
			m.UpdateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecommendVersion", wireType)
			}
			m.RecommendVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecommendVersion |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBase
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &imapigateway.UserInfo{}
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFriend", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFriend = bool(v != 0)
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecommendUID", wireType)
			}
			m.RecommendUID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecommendUID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FriendUID", wireType)
			}
			m.FriendUID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FriendUID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FollowUID", wireType)
			}
			m.FollowUID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FollowUID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserRecommendVersion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserRecommendVersion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserRecommendVersion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBase
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TagAddReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TagAddReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TagAddReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBase
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tag == nil {
				m.Tag = &Tag{}
			}
			if err := m.Tag.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserTags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBase
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserTags = append(m.UserTags, &UserTag{})
			if err := m.UserTags[len(m.UserTags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TagAddRep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TagAddRep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TagAddRep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBase
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tag == nil {
				m.Tag = &Tag{}
			}
			if err := m.Tag.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserTags) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserTags: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserTags: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBase
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tag == nil {
				m.Tag = &Tag{}
			}
			if err := m.Tag.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagUsers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBase
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagUsers = append(m.TagUsers, &UserTag{})
			if err := m.TagUsers[len(m.TagUsers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TagGetReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TagGetReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TagGetReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TagGetRep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TagGetRep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TagGetRep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserTags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBase
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserTags = append(m.UserTags, &UserTags{})
			if err := m.UserTags[len(m.UserTags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagID", wireType)
			}
			m.TagID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TagID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBase
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateBy", wireType)
			}
			m.CreateBy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateBy |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserTag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserTag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserTag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserTagID", wireType)
			}
			m.UserTagID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserTagID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagID", wireType)
			}
			m.TagID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TagID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateBy", wireType)
			}
			m.CreateBy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateBy |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserRecommend) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserRecommend: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserRecommend: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForumType", wireType)
			}
			m.ForumType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForumType |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateBy", wireType)
			}
			m.CreateBy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateBy |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mark", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBase
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mark = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitVIP", wireType)
			}
			m.LimitVIP = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitVIP |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Page) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Page: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Page: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRows", wireType)
			}
			m.TotalRows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalRows |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageCount", wireType)
			}
			m.PageCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentPage", wireType)
			}
			m.CurrentPage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentPage |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBase
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Order = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBase
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sort = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBase(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBase
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBase
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBase
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBase
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBase
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBase
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBase        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBase          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBase = fmt.Errorf("proto: unexpected end of group")
)
