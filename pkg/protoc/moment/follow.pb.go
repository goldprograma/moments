// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: follow.proto

package moment

import (
	context "context"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"
	"gitlab.moments.im/pkg/protoc/imapigateway"

	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type FollowAllOrderByCreateAtReq struct {
	CreateAt             int32    `protobuf:"varint,1,opt,name=CreateAt,proto3" json:"CreateAt,omitempty"`
	UserID               int32    `protobuf:"varint,2,opt,name=UserID,proto3" json:"UserID,omitempty"`
	Limit                int32    `protobuf:"varint,3,opt,name=Limit,proto3" json:"Limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FollowAllOrderByCreateAtReq) Reset()         { *m = FollowAllOrderByCreateAtReq{} }
func (m *FollowAllOrderByCreateAtReq) String() string { return proto.CompactTextString(m) }
func (*FollowAllOrderByCreateAtReq) ProtoMessage()    {}
func (*FollowAllOrderByCreateAtReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_a311fc0325a30114, []int{0}
}
func (m *FollowAllOrderByCreateAtReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FollowAllOrderByCreateAtReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FollowAllOrderByCreateAtReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FollowAllOrderByCreateAtReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FollowAllOrderByCreateAtReq.Merge(m, src)
}
func (m *FollowAllOrderByCreateAtReq) XXX_Size() int {
	return m.Size()
}
func (m *FollowAllOrderByCreateAtReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FollowAllOrderByCreateAtReq.DiscardUnknown(m)
}

var xxx_messageInfo_FollowAllOrderByCreateAtReq proto.InternalMessageInfo

func (m *FollowAllOrderByCreateAtReq) GetCreateAt() int32 {
	if m != nil {
		return m.CreateAt
	}
	return 0
}

func (m *FollowAllOrderByCreateAtReq) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *FollowAllOrderByCreateAtReq) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type FollowAllOrderByCreateAtResp struct {
	Follows              []*Follow `protobuf:"bytes,1,rep,name=Follows,proto3" json:"Follows,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *FollowAllOrderByCreateAtResp) Reset()         { *m = FollowAllOrderByCreateAtResp{} }
func (m *FollowAllOrderByCreateAtResp) String() string { return proto.CompactTextString(m) }
func (*FollowAllOrderByCreateAtResp) ProtoMessage()    {}
func (*FollowAllOrderByCreateAtResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_a311fc0325a30114, []int{1}
}
func (m *FollowAllOrderByCreateAtResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FollowAllOrderByCreateAtResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FollowAllOrderByCreateAtResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FollowAllOrderByCreateAtResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FollowAllOrderByCreateAtResp.Merge(m, src)
}
func (m *FollowAllOrderByCreateAtResp) XXX_Size() int {
	return m.Size()
}
func (m *FollowAllOrderByCreateAtResp) XXX_DiscardUnknown() {
	xxx_messageInfo_FollowAllOrderByCreateAtResp.DiscardUnknown(m)
}

var xxx_messageInfo_FollowAllOrderByCreateAtResp proto.InternalMessageInfo

func (m *FollowAllOrderByCreateAtResp) GetFollows() []*Follow {
	if m != nil {
		return m.Follows
	}
	return nil
}

type FollowPageRep struct {
	Follows              []*Follow                `protobuf:"bytes,1,rep,name=Follows,proto3" json:"Follows,omitempty"`
	Users                []*imapigateway.UserInfo `protobuf:"bytes,2,rep,name=Users,proto3" json:"Users,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *FollowPageRep) Reset()         { *m = FollowPageRep{} }
func (m *FollowPageRep) String() string { return proto.CompactTextString(m) }
func (*FollowPageRep) ProtoMessage()    {}
func (*FollowPageRep) Descriptor() ([]byte, []int) {
	return fileDescriptor_a311fc0325a30114, []int{2}
}
func (m *FollowPageRep) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FollowPageRep) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FollowPageRep.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FollowPageRep) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FollowPageRep.Merge(m, src)
}
func (m *FollowPageRep) XXX_Size() int {
	return m.Size()
}
func (m *FollowPageRep) XXX_DiscardUnknown() {
	xxx_messageInfo_FollowPageRep.DiscardUnknown(m)
}

var xxx_messageInfo_FollowPageRep proto.InternalMessageInfo

func (m *FollowPageRep) GetFollows() []*Follow {
	if m != nil {
		return m.Follows
	}
	return nil
}

func (m *FollowPageRep) GetUsers() []*imapigateway.UserInfo {
	if m != nil {
		return m.Users
	}
	return nil
}

type FansIDReq struct {
	UserID               int32    `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	UserName             string   `protobuf:"bytes,2,opt,name=UserName,proto3" json:"UserName,omitempty"`
	Offset               int32    `protobuf:"varint,3,opt,name=Offset,proto3" json:"Offset,omitempty"`
	Limit                int32    `protobuf:"varint,4,opt,name=Limit,proto3" json:"Limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FansIDReq) Reset()         { *m = FansIDReq{} }
func (m *FansIDReq) String() string { return proto.CompactTextString(m) }
func (*FansIDReq) ProtoMessage()    {}
func (*FansIDReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_a311fc0325a30114, []int{3}
}
func (m *FansIDReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FansIDReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FansIDReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FansIDReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FansIDReq.Merge(m, src)
}
func (m *FansIDReq) XXX_Size() int {
	return m.Size()
}
func (m *FansIDReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FansIDReq.DiscardUnknown(m)
}

var xxx_messageInfo_FansIDReq proto.InternalMessageInfo

func (m *FansIDReq) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *FansIDReq) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

func (m *FansIDReq) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *FansIDReq) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type FansIDResp struct {
	UID                  []int32  `protobuf:"varint,1,rep,packed,name=UID,proto3" json:"UID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FansIDResp) Reset()         { *m = FansIDResp{} }
func (m *FansIDResp) String() string { return proto.CompactTextString(m) }
func (*FansIDResp) ProtoMessage()    {}
func (*FansIDResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_a311fc0325a30114, []int{4}
}
func (m *FansIDResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FansIDResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FansIDResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FansIDResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FansIDResp.Merge(m, src)
}
func (m *FansIDResp) XXX_Size() int {
	return m.Size()
}
func (m *FansIDResp) XXX_DiscardUnknown() {
	xxx_messageInfo_FansIDResp.DiscardUnknown(m)
}

var xxx_messageInfo_FansIDResp proto.InternalMessageInfo

func (m *FansIDResp) GetUID() []int32 {
	if m != nil {
		return m.UID
	}
	return nil
}

type FansCountBySourceResp struct {
	Count                int32    `protobuf:"varint,1,opt,name=Count,proto3" json:"Count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FansCountBySourceResp) Reset()         { *m = FansCountBySourceResp{} }
func (m *FansCountBySourceResp) String() string { return proto.CompactTextString(m) }
func (*FansCountBySourceResp) ProtoMessage()    {}
func (*FansCountBySourceResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_a311fc0325a30114, []int{5}
}
func (m *FansCountBySourceResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FansCountBySourceResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FansCountBySourceResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FansCountBySourceResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FansCountBySourceResp.Merge(m, src)
}
func (m *FansCountBySourceResp) XXX_Size() int {
	return m.Size()
}
func (m *FansCountBySourceResp) XXX_DiscardUnknown() {
	xxx_messageInfo_FansCountBySourceResp.DiscardUnknown(m)
}

var xxx_messageInfo_FansCountBySourceResp proto.InternalMessageInfo

func (m *FansCountBySourceResp) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

type FollowAllIDRep struct {
	Fans                 []int32  `protobuf:"varint,1,rep,packed,name=Fans,proto3" json:"Fans,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FollowAllIDRep) Reset()         { *m = FollowAllIDRep{} }
func (m *FollowAllIDRep) String() string { return proto.CompactTextString(m) }
func (*FollowAllIDRep) ProtoMessage()    {}
func (*FollowAllIDRep) Descriptor() ([]byte, []int) {
	return fileDescriptor_a311fc0325a30114, []int{6}
}
func (m *FollowAllIDRep) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FollowAllIDRep) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FollowAllIDRep.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FollowAllIDRep) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FollowAllIDRep.Merge(m, src)
}
func (m *FollowAllIDRep) XXX_Size() int {
	return m.Size()
}
func (m *FollowAllIDRep) XXX_DiscardUnknown() {
	xxx_messageInfo_FollowAllIDRep.DiscardUnknown(m)
}

var xxx_messageInfo_FollowAllIDRep proto.InternalMessageInfo

func (m *FollowAllIDRep) GetFans() []int32 {
	if m != nil {
		return m.Fans
	}
	return nil
}

type FansAllIDRep struct {
	Fans                 []int32  `protobuf:"varint,1,rep,packed,name=Fans,proto3" json:"Fans,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FansAllIDRep) Reset()         { *m = FansAllIDRep{} }
func (m *FansAllIDRep) String() string { return proto.CompactTextString(m) }
func (*FansAllIDRep) ProtoMessage()    {}
func (*FansAllIDRep) Descriptor() ([]byte, []int) {
	return fileDescriptor_a311fc0325a30114, []int{7}
}
func (m *FansAllIDRep) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FansAllIDRep) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FansAllIDRep.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FansAllIDRep) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FansAllIDRep.Merge(m, src)
}
func (m *FansAllIDRep) XXX_Size() int {
	return m.Size()
}
func (m *FansAllIDRep) XXX_DiscardUnknown() {
	xxx_messageInfo_FansAllIDRep.DiscardUnknown(m)
}

var xxx_messageInfo_FansAllIDRep proto.InternalMessageInfo

func (m *FansAllIDRep) GetFans() []int32 {
	if m != nil {
		return m.Fans
	}
	return nil
}

type FollowCountReq struct {
	UserID               int32    `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FollowCountReq) Reset()         { *m = FollowCountReq{} }
func (m *FollowCountReq) String() string { return proto.CompactTextString(m) }
func (*FollowCountReq) ProtoMessage()    {}
func (*FollowCountReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_a311fc0325a30114, []int{8}
}
func (m *FollowCountReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FollowCountReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FollowCountReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FollowCountReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FollowCountReq.Merge(m, src)
}
func (m *FollowCountReq) XXX_Size() int {
	return m.Size()
}
func (m *FollowCountReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FollowCountReq.DiscardUnknown(m)
}

var xxx_messageInfo_FollowCountReq proto.InternalMessageInfo

func (m *FollowCountReq) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

type FollowCountRep struct {
	// @inject_tag: json:"Count"
	Count                int64    `protobuf:"varint,1,opt,name=Count,proto3" json:"Count"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FollowCountRep) Reset()         { *m = FollowCountRep{} }
func (m *FollowCountRep) String() string { return proto.CompactTextString(m) }
func (*FollowCountRep) ProtoMessage()    {}
func (*FollowCountRep) Descriptor() ([]byte, []int) {
	return fileDescriptor_a311fc0325a30114, []int{9}
}
func (m *FollowCountRep) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FollowCountRep) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FollowCountRep.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FollowCountRep) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FollowCountRep.Merge(m, src)
}
func (m *FollowCountRep) XXX_Size() int {
	return m.Size()
}
func (m *FollowCountRep) XXX_DiscardUnknown() {
	xxx_messageInfo_FollowCountRep.DiscardUnknown(m)
}

var xxx_messageInfo_FollowCountRep proto.InternalMessageInfo

func (m *FollowCountRep) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type FollowPageReq struct {
	UserName             string   `protobuf:"bytes,1,opt,name=UserName,proto3" json:"UserName,omitempty"`
	CreateBy             int32    `protobuf:"varint,2,opt,name=CreateBy,proto3" json:"CreateBy,omitempty"`
	Offset               int32    `protobuf:"varint,3,opt,name=Offset,proto3" json:"Offset,omitempty"`
	Limit                int32    `protobuf:"varint,4,opt,name=Limit,proto3" json:"Limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FollowPageReq) Reset()         { *m = FollowPageReq{} }
func (m *FollowPageReq) String() string { return proto.CompactTextString(m) }
func (*FollowPageReq) ProtoMessage()    {}
func (*FollowPageReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_a311fc0325a30114, []int{10}
}
func (m *FollowPageReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FollowPageReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FollowPageReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FollowPageReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FollowPageReq.Merge(m, src)
}
func (m *FollowPageReq) XXX_Size() int {
	return m.Size()
}
func (m *FollowPageReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FollowPageReq.DiscardUnknown(m)
}

var xxx_messageInfo_FollowPageReq proto.InternalMessageInfo

func (m *FollowPageReq) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

func (m *FollowPageReq) GetCreateBy() int32 {
	if m != nil {
		return m.CreateBy
	}
	return 0
}

func (m *FollowPageReq) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *FollowPageReq) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type Follow struct {
	// @inject_tag: db:"id"
	ID int64 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty" db:"id"`
	// @inject_tag: db:"follow_id"
	FollowID int64 `protobuf:"varint,2,opt,name=FollowID,proto3" json:"FollowID,omitempty" db:"follow_id"`
	// FollowUID 被关注人ID
	// @inject_tag: db:"follow_uid"
	FollowUID int32 `protobuf:"varint,3,opt,name=FollowUID,proto3" json:"FollowUID,omitempty" db:"follow_uid"`
	//EachOther 是否互相关注
	// @inject_tag: db:"each_other" update:"force"
	EachOther int32 `protobuf:"varint,4,opt,name=EachOther,proto3" json:"EachOther,omitempty" db:"each_other" update:"force"`
	// CreateAt 关注时间
	// @inject_tag: db:"create_at"
	CreateAt int64 `protobuf:"varint,5,opt,name=CreateAt,proto3" json:"CreateAt,omitempty" db:"create_at"`
	// UserID 用户ID
	// @inject_tag: db:"create_by"
	CreateBy int32 `protobuf:"varint,6,opt,name=CreateBy,proto3" json:"CreateBy,omitempty" db:"create_by"`
	// FollowSource 关注来源 给直播使用 暂不开启
	// @inject_tag: db:"follow_source"
	FollowSource         int64    `protobuf:"varint,7,opt,name=FollowSource,proto3" json:"FollowSource,omitempty" db:"follow_source"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Follow) Reset()         { *m = Follow{} }
func (m *Follow) String() string { return proto.CompactTextString(m) }
func (*Follow) ProtoMessage()    {}
func (*Follow) Descriptor() ([]byte, []int) {
	return fileDescriptor_a311fc0325a30114, []int{11}
}
func (m *Follow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Follow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Follow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Follow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Follow.Merge(m, src)
}
func (m *Follow) XXX_Size() int {
	return m.Size()
}
func (m *Follow) XXX_DiscardUnknown() {
	xxx_messageInfo_Follow.DiscardUnknown(m)
}

var xxx_messageInfo_Follow proto.InternalMessageInfo

func (m *Follow) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Follow) GetFollowID() int64 {
	if m != nil {
		return m.FollowID
	}
	return 0
}

func (m *Follow) GetFollowUID() int32 {
	if m != nil {
		return m.FollowUID
	}
	return 0
}

func (m *Follow) GetEachOther() int32 {
	if m != nil {
		return m.EachOther
	}
	return 0
}

func (m *Follow) GetCreateAt() int64 {
	if m != nil {
		return m.CreateAt
	}
	return 0
}

func (m *Follow) GetCreateBy() int32 {
	if m != nil {
		return m.CreateBy
	}
	return 0
}

func (m *Follow) GetFollowSource() int64 {
	if m != nil {
		return m.FollowSource
	}
	return 0
}

func init() {
	proto.RegisterType((*FollowAllOrderByCreateAtReq)(nil), "moment.FollowAllOrderByCreateAtReq")
	proto.RegisterType((*FollowAllOrderByCreateAtResp)(nil), "moment.FollowAllOrderByCreateAtResp")
	proto.RegisterType((*FollowPageRep)(nil), "moment.FollowPageRep")
	proto.RegisterType((*FansIDReq)(nil), "moment.FansIDReq")
	proto.RegisterType((*FansIDResp)(nil), "moment.FansIDResp")
	proto.RegisterType((*FansCountBySourceResp)(nil), "moment.FansCountBySourceResp")
	proto.RegisterType((*FollowAllIDRep)(nil), "moment.FollowAllIDRep")
	proto.RegisterType((*FansAllIDRep)(nil), "moment.FansAllIDRep")
	proto.RegisterType((*FollowCountReq)(nil), "moment.FollowCountReq")
	proto.RegisterType((*FollowCountRep)(nil), "moment.FollowCountRep")
	proto.RegisterType((*FollowPageReq)(nil), "moment.FollowPageReq")
	proto.RegisterType((*Follow)(nil), "moment.Follow")
}

func init() { proto.RegisterFile("follow.proto", fileDescriptor_a311fc0325a30114) }

var fileDescriptor_a311fc0325a30114 = []byte{
	// 673 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0x5f, 0x6f, 0xd2, 0x50,
	0x14, 0x5f, 0xe9, 0xda, 0x6d, 0x67, 0x88, 0xee, 0x86, 0x91, 0x5a, 0x27, 0x59, 0xae, 0x8b, 0x12,
	0xa3, 0x24, 0xb2, 0x44, 0x63, 0x8c, 0x31, 0x30, 0x9c, 0x92, 0x2c, 0x62, 0xba, 0xec, 0x03, 0x54,
	0xb8, 0x30, 0x92, 0xfe, 0x5b, 0x7b, 0x71, 0xe1, 0x9b, 0xf9, 0x11, 0x7c, 0xf0, 0xc1, 0x67, 0x9f,
	0x0c, 0x9f, 0xc4, 0xdc, 0x7b, 0xdb, 0xd2, 0x3f, 0x6c, 0x52, 0xf6, 0xc4, 0x3d, 0xff, 0xcf, 0xf9,
	0x9d, 0x3f, 0x05, 0xca, 0x23, 0xd7, 0xb2, 0xdc, 0xeb, 0xa6, 0xe7, 0xbb, 0xd4, 0x45, 0xaa, 0xed,
	0xda, 0xc4, 0xa1, 0x7a, 0x79, 0xe0, 0xda, 0xb6, 0xeb, 0x08, 0x2e, 0x1e, 0xc3, 0xa3, 0x53, 0xae,
	0xd5, 0xb6, 0xac, 0xbe, 0x3f, 0x24, 0x7e, 0x67, 0x76, 0xe2, 0x13, 0x93, 0x92, 0x36, 0x35, 0xc8,
	0x15, 0xd2, 0x61, 0x3b, 0x22, 0x35, 0xe9, 0x50, 0x6a, 0x28, 0x46, 0x4c, 0xa3, 0x1a, 0xa8, 0x17,
	0x01, 0xf1, 0x7b, 0x5d, 0xad, 0xc4, 0x25, 0x21, 0x85, 0xaa, 0xa0, 0x9c, 0x4d, 0xec, 0x09, 0xd5,
	0x64, 0xce, 0x16, 0x04, 0xfe, 0x0c, 0x07, 0x37, 0x07, 0x0a, 0x3c, 0xd4, 0x80, 0x2d, 0x21, 0x0f,
	0x34, 0xe9, 0x50, 0x6e, 0xec, 0xb6, 0x2a, 0x4d, 0x91, 0x70, 0x53, 0xb0, 0x8d, 0x48, 0x8c, 0xc7,
	0x70, 0x4f, 0x3c, 0xbf, 0x9a, 0x63, 0x62, 0x90, 0x02, 0xa6, 0xe8, 0x05, 0x28, 0x2c, 0xc9, 0x40,
	0x2b, 0x71, 0xbd, 0x5a, 0x73, 0x62, 0x9b, 0xde, 0x64, 0x6c, 0x52, 0x72, 0x6d, 0xce, 0x9a, 0x53,
	0x96, 0xbf, 0x33, 0x72, 0x0d, 0xa1, 0x84, 0x6d, 0xd8, 0x39, 0x35, 0x9d, 0xa0, 0xd7, 0x65, 0x48,
	0x2c, 0xaa, 0x95, 0x52, 0xd5, 0xea, 0xb0, 0xcd, 0x5e, 0x5f, 0x4c, 0x9b, 0x70, 0x1c, 0x76, 0x8c,
	0x98, 0x66, 0x36, 0xfd, 0xd1, 0x28, 0x20, 0x11, 0x14, 0x21, 0xb5, 0x40, 0x68, 0x33, 0x89, 0x50,
	0x1d, 0x20, 0x0a, 0x17, 0x78, 0xe8, 0x01, 0xc8, 0x17, 0x3c, 0x98, 0xdc, 0x50, 0x0c, 0xf6, 0xc4,
	0x2f, 0x61, 0x9f, 0xc9, 0x4f, 0xdc, 0xa9, 0x43, 0x3b, 0xb3, 0x73, 0x77, 0xea, 0x0f, 0x08, 0x57,
	0xad, 0x82, 0xc2, 0x99, 0x61, 0x66, 0x82, 0xc0, 0x47, 0x50, 0x89, 0x01, 0x67, 0x3e, 0x3d, 0x84,
	0x60, 0x93, 0x39, 0x08, 0x7d, 0xf2, 0x37, 0xc6, 0x50, 0x66, 0xbf, 0xb7, 0xea, 0x34, 0x22, 0x4f,
	0xdc, 0xf1, 0x2d, 0x60, 0xe0, 0xa7, 0x19, 0xcd, 0x4c, 0x6e, 0x72, 0x94, 0xdb, 0x34, 0xdd, 0xc2,
	0xab, 0x14, 0x8a, 0x52, 0x06, 0xc5, 0x78, 0x06, 0x3b, 0xb3, 0x70, 0xd2, 0x62, 0xba, 0x20, 0xc2,
	0xbf, 0x24, 0x50, 0x45, 0x5c, 0x54, 0x81, 0x52, 0x98, 0xbd, 0x6c, 0x94, 0x44, 0x1b, 0x85, 0x24,
	0x1c, 0x67, 0xd9, 0x88, 0x69, 0x74, 0x00, 0x3b, 0xe2, 0xcd, 0x1a, 0x22, 0xe2, 0x2c, 0x18, 0x4c,
	0xfa, 0xd1, 0x1c, 0x5c, 0xf6, 0xe9, 0x25, 0xf1, 0xc3, 0x70, 0x0b, 0x46, 0x6a, 0x81, 0x14, 0xe1,
	0x37, 0x5e, 0xa0, 0x64, 0x61, 0x6a, 0xa6, 0x30, 0xd6, 0x17, 0x1e, 0x42, 0xf4, 0x59, 0xdb, 0xe2,
	0xb6, 0x29, 0x5e, 0xeb, 0x8f, 0x0a, 0xf7, 0x05, 0xa3, 0xdb, 0x39, 0x27, 0xfe, 0xf7, 0xc9, 0x80,
	0xa0, 0x67, 0x20, 0xb7, 0x87, 0x43, 0x94, 0xd9, 0x00, 0x3d, 0x43, 0xe3, 0x0d, 0xa6, 0xf8, 0x89,
	0xd0, 0x15, 0x14, 0x9f, 0x83, 0xda, 0x25, 0x16, 0xa1, 0x64, 0x05, 0xdd, 0xb7, 0xf1, 0x26, 0xa2,
	0xfd, 0xb4, 0x30, 0x6c, 0xb4, 0xbe, 0x94, 0xed, 0xe1, 0x0d, 0xf4, 0x5a, 0x0c, 0x5e, 0x61, 0x3b,
	0x16, 0x52, 0x0c, 0x70, 0x61, 0xd3, 0x0f, 0xb0, 0x9b, 0x98, 0x56, 0x54, 0x4b, 0xeb, 0x45, 0xc3,
	0xae, 0x2f, 0xe7, 0x33, 0x07, 0xef, 0xc5, 0x81, 0x58, 0xd7, 0xfc, 0x58, 0x98, 0xf3, 0xdd, 0xcb,
	0x81, 0x5b, 0x8d, 0xe9, 0xc4, 0x7a, 0xe2, 0x0d, 0xf4, 0x26, 0x4a, 0x7a, 0xb9, 0x59, 0x26, 0x5a,
	0xc2, 0xf0, 0x5d, 0x34, 0xc5, 0xeb, 0x40, 0x75, 0x06, 0x0f, 0x73, 0xb7, 0xa7, 0xe7, 0x50, 0xe2,
	0x3b, 0xa6, 0x95, 0xcb, 0xe1, 0x71, 0x32, 0xf5, 0xdc, 0xb9, 0xe2, 0x3d, 0xab, 0x88, 0x4b, 0x17,
	0xbb, 0xd8, 0x4b, 0x9a, 0xf0, 0x83, 0xab, 0xa3, 0x2c, 0x8b, 0x9b, 0x8e, 0x41, 0xbb, 0xe9, 0x33,
	0x82, 0x9e, 0xe4, 0x6a, 0xcf, 0x7f, 0xd1, 0xf4, 0xa3, 0xff, 0x2b, 0xb1, 0x40, 0xad, 0x1f, 0x72,
	0x74, 0xa3, 0x0a, 0xaf, 0x56, 0x91, 0x8d, 0xe9, 0xc2, 0x5e, 0x0e, 0xa5, 0xe2, 0x80, 0xae, 0xbc,
	0xcc, 0xaf, 0x40, 0x15, 0x70, 0xae, 0x8e, 0xf8, 0x5d, 0x16, 0x73, 0xcd, 0x5b, 0x70, 0xb7, 0xbd,
	0xea, 0x94, 0x7f, 0xce, 0xeb, 0xd2, 0xef, 0x79, 0x5d, 0xfa, 0x3b, 0xaf, 0x4b, 0xdf, 0x54, 0xfe,
	0x47, 0xe7, 0xf8, 0x5f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x51, 0x3b, 0xaa, 0x8e, 0x0e, 0x09, 0x00,
	0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// FollowDBServiceClient is the client API for FollowDBService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type FollowDBServiceClient interface {
	Add(ctx context.Context, in *Follow, opts ...grpc.CallOption) (*Follow, error)
	Get(ctx context.Context, in *Follow, opts ...grpc.CallOption) (*Follow, error)
	Delete(ctx context.Context, in *Follow, opts ...grpc.CallOption) (*Follow, error)
	Follows(ctx context.Context, in *FollowPageReq, opts ...grpc.CallOption) (*FollowPageRep, error)
	Fans(ctx context.Context, in *FollowPageReq, opts ...grpc.CallOption) (*FollowPageRep, error)
	FansAll(ctx context.Context, in *FollowPageReq, opts ...grpc.CallOption) (*FollowPageRep, error)
	FollowCount(ctx context.Context, in *FollowCountReq, opts ...grpc.CallOption) (*FollowCountRep, error)
	FansCount(ctx context.Context, in *FollowCountReq, opts ...grpc.CallOption) (*FollowCountRep, error)
	FansAllID(ctx context.Context, in *Follow, opts ...grpc.CallOption) (*FansAllIDRep, error)
	FollowAllID(ctx context.Context, in *Follow, opts ...grpc.CallOption) (*FollowAllIDRep, error)
	FollowAll(ctx context.Context, in *FollowPageReq, opts ...grpc.CallOption) (*FollowPageRep, error)
	FansCountBySourceInternal(ctx context.Context, in *Follow, opts ...grpc.CallOption) (*FansCountBySourceResp, error)
	FansIDInternal(ctx context.Context, in *FansIDReq, opts ...grpc.CallOption) (*FansIDResp, error)
	FollowAllOrderByCreateAt(ctx context.Context, in *FollowAllOrderByCreateAtReq, opts ...grpc.CallOption) (*FollowAllOrderByCreateAtResp, error)
}

type followDBServiceClient struct {
	cc *grpc.ClientConn
}

func NewFollowDBServiceClient(cc *grpc.ClientConn) FollowDBServiceClient {
	return &followDBServiceClient{cc}
}

func (c *followDBServiceClient) Add(ctx context.Context, in *Follow, opts ...grpc.CallOption) (*Follow, error) {
	out := new(Follow)
	err := c.cc.Invoke(ctx, "/moment.FollowDBService/Add", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *followDBServiceClient) Get(ctx context.Context, in *Follow, opts ...grpc.CallOption) (*Follow, error) {
	out := new(Follow)
	err := c.cc.Invoke(ctx, "/moment.FollowDBService/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *followDBServiceClient) Delete(ctx context.Context, in *Follow, opts ...grpc.CallOption) (*Follow, error) {
	out := new(Follow)
	err := c.cc.Invoke(ctx, "/moment.FollowDBService/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *followDBServiceClient) Follows(ctx context.Context, in *FollowPageReq, opts ...grpc.CallOption) (*FollowPageRep, error) {
	out := new(FollowPageRep)
	err := c.cc.Invoke(ctx, "/moment.FollowDBService/Follows", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *followDBServiceClient) Fans(ctx context.Context, in *FollowPageReq, opts ...grpc.CallOption) (*FollowPageRep, error) {
	out := new(FollowPageRep)
	err := c.cc.Invoke(ctx, "/moment.FollowDBService/Fans", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *followDBServiceClient) FansAll(ctx context.Context, in *FollowPageReq, opts ...grpc.CallOption) (*FollowPageRep, error) {
	out := new(FollowPageRep)
	err := c.cc.Invoke(ctx, "/moment.FollowDBService/FansAll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *followDBServiceClient) FollowCount(ctx context.Context, in *FollowCountReq, opts ...grpc.CallOption) (*FollowCountRep, error) {
	out := new(FollowCountRep)
	err := c.cc.Invoke(ctx, "/moment.FollowDBService/FollowCount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *followDBServiceClient) FansCount(ctx context.Context, in *FollowCountReq, opts ...grpc.CallOption) (*FollowCountRep, error) {
	out := new(FollowCountRep)
	err := c.cc.Invoke(ctx, "/moment.FollowDBService/FansCount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *followDBServiceClient) FansAllID(ctx context.Context, in *Follow, opts ...grpc.CallOption) (*FansAllIDRep, error) {
	out := new(FansAllIDRep)
	err := c.cc.Invoke(ctx, "/moment.FollowDBService/FansAllID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *followDBServiceClient) FollowAllID(ctx context.Context, in *Follow, opts ...grpc.CallOption) (*FollowAllIDRep, error) {
	out := new(FollowAllIDRep)
	err := c.cc.Invoke(ctx, "/moment.FollowDBService/FollowAllID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *followDBServiceClient) FollowAll(ctx context.Context, in *FollowPageReq, opts ...grpc.CallOption) (*FollowPageRep, error) {
	out := new(FollowPageRep)
	err := c.cc.Invoke(ctx, "/moment.FollowDBService/FollowAll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *followDBServiceClient) FansCountBySourceInternal(ctx context.Context, in *Follow, opts ...grpc.CallOption) (*FansCountBySourceResp, error) {
	out := new(FansCountBySourceResp)
	err := c.cc.Invoke(ctx, "/moment.FollowDBService/FansCountBySourceInternal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *followDBServiceClient) FansIDInternal(ctx context.Context, in *FansIDReq, opts ...grpc.CallOption) (*FansIDResp, error) {
	out := new(FansIDResp)
	err := c.cc.Invoke(ctx, "/moment.FollowDBService/FansIDInternal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *followDBServiceClient) FollowAllOrderByCreateAt(ctx context.Context, in *FollowAllOrderByCreateAtReq, opts ...grpc.CallOption) (*FollowAllOrderByCreateAtResp, error) {
	out := new(FollowAllOrderByCreateAtResp)
	err := c.cc.Invoke(ctx, "/moment.FollowDBService/FollowAllOrderByCreateAt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FollowDBServiceServer is the server API for FollowDBService service.
type FollowDBServiceServer interface {
	Add(context.Context, *Follow) (*Follow, error)
	Get(context.Context, *Follow) (*Follow, error)
	Delete(context.Context, *Follow) (*Follow, error)
	Follows(context.Context, *FollowPageReq) (*FollowPageRep, error)
	Fans(context.Context, *FollowPageReq) (*FollowPageRep, error)
	FansAll(context.Context, *FollowPageReq) (*FollowPageRep, error)
	FollowCount(context.Context, *FollowCountReq) (*FollowCountRep, error)
	FansCount(context.Context, *FollowCountReq) (*FollowCountRep, error)
	FansAllID(context.Context, *Follow) (*FansAllIDRep, error)
	FollowAllID(context.Context, *Follow) (*FollowAllIDRep, error)
	FollowAll(context.Context, *FollowPageReq) (*FollowPageRep, error)
	FansCountBySourceInternal(context.Context, *Follow) (*FansCountBySourceResp, error)
	FansIDInternal(context.Context, *FansIDReq) (*FansIDResp, error)
	FollowAllOrderByCreateAt(context.Context, *FollowAllOrderByCreateAtReq) (*FollowAllOrderByCreateAtResp, error)
}

// UnimplementedFollowDBServiceServer can be embedded to have forward compatible implementations.
type UnimplementedFollowDBServiceServer struct {
}

func (*UnimplementedFollowDBServiceServer) Add(ctx context.Context, req *Follow) (*Follow, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Add not implemented")
}
func (*UnimplementedFollowDBServiceServer) Get(ctx context.Context, req *Follow) (*Follow, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (*UnimplementedFollowDBServiceServer) Delete(ctx context.Context, req *Follow) (*Follow, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (*UnimplementedFollowDBServiceServer) Follows(ctx context.Context, req *FollowPageReq) (*FollowPageRep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Follows not implemented")
}
func (*UnimplementedFollowDBServiceServer) Fans(ctx context.Context, req *FollowPageReq) (*FollowPageRep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Fans not implemented")
}
func (*UnimplementedFollowDBServiceServer) FansAll(ctx context.Context, req *FollowPageReq) (*FollowPageRep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FansAll not implemented")
}
func (*UnimplementedFollowDBServiceServer) FollowCount(ctx context.Context, req *FollowCountReq) (*FollowCountRep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FollowCount not implemented")
}
func (*UnimplementedFollowDBServiceServer) FansCount(ctx context.Context, req *FollowCountReq) (*FollowCountRep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FansCount not implemented")
}
func (*UnimplementedFollowDBServiceServer) FansAllID(ctx context.Context, req *Follow) (*FansAllIDRep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FansAllID not implemented")
}
func (*UnimplementedFollowDBServiceServer) FollowAllID(ctx context.Context, req *Follow) (*FollowAllIDRep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FollowAllID not implemented")
}
func (*UnimplementedFollowDBServiceServer) FollowAll(ctx context.Context, req *FollowPageReq) (*FollowPageRep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FollowAll not implemented")
}
func (*UnimplementedFollowDBServiceServer) FansCountBySourceInternal(ctx context.Context, req *Follow) (*FansCountBySourceResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FansCountBySourceInternal not implemented")
}
func (*UnimplementedFollowDBServiceServer) FansIDInternal(ctx context.Context, req *FansIDReq) (*FansIDResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FansIDInternal not implemented")
}
func (*UnimplementedFollowDBServiceServer) FollowAllOrderByCreateAt(ctx context.Context, req *FollowAllOrderByCreateAtReq) (*FollowAllOrderByCreateAtResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FollowAllOrderByCreateAt not implemented")
}

func RegisterFollowDBServiceServer(s *grpc.Server, srv FollowDBServiceServer) {
	s.RegisterService(&_FollowDBService_serviceDesc, srv)
}

func _FollowDBService_Add_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Follow)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FollowDBServiceServer).Add(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.FollowDBService/Add",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FollowDBServiceServer).Add(ctx, req.(*Follow))
	}
	return interceptor(ctx, in, info, handler)
}

func _FollowDBService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Follow)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FollowDBServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.FollowDBService/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FollowDBServiceServer).Get(ctx, req.(*Follow))
	}
	return interceptor(ctx, in, info, handler)
}

func _FollowDBService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Follow)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FollowDBServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.FollowDBService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FollowDBServiceServer).Delete(ctx, req.(*Follow))
	}
	return interceptor(ctx, in, info, handler)
}

func _FollowDBService_Follows_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FollowPageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FollowDBServiceServer).Follows(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.FollowDBService/Follows",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FollowDBServiceServer).Follows(ctx, req.(*FollowPageReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FollowDBService_Fans_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FollowPageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FollowDBServiceServer).Fans(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.FollowDBService/Fans",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FollowDBServiceServer).Fans(ctx, req.(*FollowPageReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FollowDBService_FansAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FollowPageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FollowDBServiceServer).FansAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.FollowDBService/FansAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FollowDBServiceServer).FansAll(ctx, req.(*FollowPageReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FollowDBService_FollowCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FollowCountReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FollowDBServiceServer).FollowCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.FollowDBService/FollowCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FollowDBServiceServer).FollowCount(ctx, req.(*FollowCountReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FollowDBService_FansCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FollowCountReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FollowDBServiceServer).FansCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.FollowDBService/FansCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FollowDBServiceServer).FansCount(ctx, req.(*FollowCountReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FollowDBService_FansAllID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Follow)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FollowDBServiceServer).FansAllID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.FollowDBService/FansAllID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FollowDBServiceServer).FansAllID(ctx, req.(*Follow))
	}
	return interceptor(ctx, in, info, handler)
}

func _FollowDBService_FollowAllID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Follow)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FollowDBServiceServer).FollowAllID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.FollowDBService/FollowAllID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FollowDBServiceServer).FollowAllID(ctx, req.(*Follow))
	}
	return interceptor(ctx, in, info, handler)
}

func _FollowDBService_FollowAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FollowPageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FollowDBServiceServer).FollowAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.FollowDBService/FollowAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FollowDBServiceServer).FollowAll(ctx, req.(*FollowPageReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FollowDBService_FansCountBySourceInternal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Follow)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FollowDBServiceServer).FansCountBySourceInternal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.FollowDBService/FansCountBySourceInternal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FollowDBServiceServer).FansCountBySourceInternal(ctx, req.(*Follow))
	}
	return interceptor(ctx, in, info, handler)
}

func _FollowDBService_FansIDInternal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FansIDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FollowDBServiceServer).FansIDInternal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.FollowDBService/FansIDInternal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FollowDBServiceServer).FansIDInternal(ctx, req.(*FansIDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FollowDBService_FollowAllOrderByCreateAt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FollowAllOrderByCreateAtReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FollowDBServiceServer).FollowAllOrderByCreateAt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.FollowDBService/FollowAllOrderByCreateAt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FollowDBServiceServer).FollowAllOrderByCreateAt(ctx, req.(*FollowAllOrderByCreateAtReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _FollowDBService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "moment.FollowDBService",
	HandlerType: (*FollowDBServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Add",
			Handler:    _FollowDBService_Add_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _FollowDBService_Get_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _FollowDBService_Delete_Handler,
		},
		{
			MethodName: "Follows",
			Handler:    _FollowDBService_Follows_Handler,
		},
		{
			MethodName: "Fans",
			Handler:    _FollowDBService_Fans_Handler,
		},
		{
			MethodName: "FansAll",
			Handler:    _FollowDBService_FansAll_Handler,
		},
		{
			MethodName: "FollowCount",
			Handler:    _FollowDBService_FollowCount_Handler,
		},
		{
			MethodName: "FansCount",
			Handler:    _FollowDBService_FansCount_Handler,
		},
		{
			MethodName: "FansAllID",
			Handler:    _FollowDBService_FansAllID_Handler,
		},
		{
			MethodName: "FollowAllID",
			Handler:    _FollowDBService_FollowAllID_Handler,
		},
		{
			MethodName: "FollowAll",
			Handler:    _FollowDBService_FollowAll_Handler,
		},
		{
			MethodName: "FansCountBySourceInternal",
			Handler:    _FollowDBService_FansCountBySourceInternal_Handler,
		},
		{
			MethodName: "FansIDInternal",
			Handler:    _FollowDBService_FansIDInternal_Handler,
		},
		{
			MethodName: "FollowAllOrderByCreateAt",
			Handler:    _FollowDBService_FollowAllOrderByCreateAt_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "follow.proto",
}

// FollowServiceClient is the client API for FollowService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type FollowServiceClient interface {
	Add(ctx context.Context, in *Follow, opts ...grpc.CallOption) (*Follow, error)
	Delete(ctx context.Context, in *Follow, opts ...grpc.CallOption) (*Follow, error)
	FansCountBySource(ctx context.Context, in *Follow, opts ...grpc.CallOption) (*FansCountBySourceResp, error)
	Get(ctx context.Context, in *Follow, opts ...grpc.CallOption) (*Follow, error)
	FansID(ctx context.Context, in *FansIDReq, opts ...grpc.CallOption) (*FansIDResp, error)
	Fans(ctx context.Context, in *FollowPageReq, opts ...grpc.CallOption) (*FollowPageRep, error)
	Follows(ctx context.Context, in *FollowPageReq, opts ...grpc.CallOption) (*FollowPageRep, error)
	FansCount(ctx context.Context, in *FollowCountReq, opts ...grpc.CallOption) (*FollowCountRep, error)
}

type followServiceClient struct {
	cc *grpc.ClientConn
}

func NewFollowServiceClient(cc *grpc.ClientConn) FollowServiceClient {
	return &followServiceClient{cc}
}

func (c *followServiceClient) Add(ctx context.Context, in *Follow, opts ...grpc.CallOption) (*Follow, error) {
	out := new(Follow)
	err := c.cc.Invoke(ctx, "/moment.FollowService/Add", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *followServiceClient) Delete(ctx context.Context, in *Follow, opts ...grpc.CallOption) (*Follow, error) {
	out := new(Follow)
	err := c.cc.Invoke(ctx, "/moment.FollowService/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *followServiceClient) FansCountBySource(ctx context.Context, in *Follow, opts ...grpc.CallOption) (*FansCountBySourceResp, error) {
	out := new(FansCountBySourceResp)
	err := c.cc.Invoke(ctx, "/moment.FollowService/FansCountBySource", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *followServiceClient) Get(ctx context.Context, in *Follow, opts ...grpc.CallOption) (*Follow, error) {
	out := new(Follow)
	err := c.cc.Invoke(ctx, "/moment.FollowService/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *followServiceClient) FansID(ctx context.Context, in *FansIDReq, opts ...grpc.CallOption) (*FansIDResp, error) {
	out := new(FansIDResp)
	err := c.cc.Invoke(ctx, "/moment.FollowService/FansID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *followServiceClient) Fans(ctx context.Context, in *FollowPageReq, opts ...grpc.CallOption) (*FollowPageRep, error) {
	out := new(FollowPageRep)
	err := c.cc.Invoke(ctx, "/moment.FollowService/Fans", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *followServiceClient) Follows(ctx context.Context, in *FollowPageReq, opts ...grpc.CallOption) (*FollowPageRep, error) {
	out := new(FollowPageRep)
	err := c.cc.Invoke(ctx, "/moment.FollowService/Follows", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *followServiceClient) FansCount(ctx context.Context, in *FollowCountReq, opts ...grpc.CallOption) (*FollowCountRep, error) {
	out := new(FollowCountRep)
	err := c.cc.Invoke(ctx, "/moment.FollowService/FansCount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FollowServiceServer is the server API for FollowService service.
type FollowServiceServer interface {
	Add(context.Context, *Follow) (*Follow, error)
	Delete(context.Context, *Follow) (*Follow, error)
	FansCountBySource(context.Context, *Follow) (*FansCountBySourceResp, error)
	Get(context.Context, *Follow) (*Follow, error)
	FansID(context.Context, *FansIDReq) (*FansIDResp, error)
	Fans(context.Context, *FollowPageReq) (*FollowPageRep, error)
	Follows(context.Context, *FollowPageReq) (*FollowPageRep, error)
	FansCount(context.Context, *FollowCountReq) (*FollowCountRep, error)
}

// UnimplementedFollowServiceServer can be embedded to have forward compatible implementations.
type UnimplementedFollowServiceServer struct {
}

func (*UnimplementedFollowServiceServer) Add(ctx context.Context, req *Follow) (*Follow, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Add not implemented")
}
func (*UnimplementedFollowServiceServer) Delete(ctx context.Context, req *Follow) (*Follow, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (*UnimplementedFollowServiceServer) FansCountBySource(ctx context.Context, req *Follow) (*FansCountBySourceResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FansCountBySource not implemented")
}
func (*UnimplementedFollowServiceServer) Get(ctx context.Context, req *Follow) (*Follow, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (*UnimplementedFollowServiceServer) FansID(ctx context.Context, req *FansIDReq) (*FansIDResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FansID not implemented")
}
func (*UnimplementedFollowServiceServer) Fans(ctx context.Context, req *FollowPageReq) (*FollowPageRep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Fans not implemented")
}
func (*UnimplementedFollowServiceServer) Follows(ctx context.Context, req *FollowPageReq) (*FollowPageRep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Follows not implemented")
}
func (*UnimplementedFollowServiceServer) FansCount(ctx context.Context, req *FollowCountReq) (*FollowCountRep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FansCount not implemented")
}

func RegisterFollowServiceServer(s *grpc.Server, srv FollowServiceServer) {
	s.RegisterService(&_FollowService_serviceDesc, srv)
}

func _FollowService_Add_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Follow)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FollowServiceServer).Add(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.FollowService/Add",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FollowServiceServer).Add(ctx, req.(*Follow))
	}
	return interceptor(ctx, in, info, handler)
}

func _FollowService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Follow)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FollowServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.FollowService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FollowServiceServer).Delete(ctx, req.(*Follow))
	}
	return interceptor(ctx, in, info, handler)
}

func _FollowService_FansCountBySource_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Follow)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FollowServiceServer).FansCountBySource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.FollowService/FansCountBySource",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FollowServiceServer).FansCountBySource(ctx, req.(*Follow))
	}
	return interceptor(ctx, in, info, handler)
}

func _FollowService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Follow)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FollowServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.FollowService/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FollowServiceServer).Get(ctx, req.(*Follow))
	}
	return interceptor(ctx, in, info, handler)
}

func _FollowService_FansID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FansIDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FollowServiceServer).FansID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.FollowService/FansID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FollowServiceServer).FansID(ctx, req.(*FansIDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FollowService_Fans_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FollowPageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FollowServiceServer).Fans(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.FollowService/Fans",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FollowServiceServer).Fans(ctx, req.(*FollowPageReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FollowService_Follows_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FollowPageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FollowServiceServer).Follows(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.FollowService/Follows",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FollowServiceServer).Follows(ctx, req.(*FollowPageReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FollowService_FansCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FollowCountReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FollowServiceServer).FansCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.FollowService/FansCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FollowServiceServer).FansCount(ctx, req.(*FollowCountReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _FollowService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "moment.FollowService",
	HandlerType: (*FollowServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Add",
			Handler:    _FollowService_Add_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _FollowService_Delete_Handler,
		},
		{
			MethodName: "FansCountBySource",
			Handler:    _FollowService_FansCountBySource_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _FollowService_Get_Handler,
		},
		{
			MethodName: "FansID",
			Handler:    _FollowService_FansID_Handler,
		},
		{
			MethodName: "Fans",
			Handler:    _FollowService_Fans_Handler,
		},
		{
			MethodName: "Follows",
			Handler:    _FollowService_Follows_Handler,
		},
		{
			MethodName: "FansCount",
			Handler:    _FollowService_FansCount_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "follow.proto",
}

func (m *FollowAllOrderByCreateAtReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FollowAllOrderByCreateAtReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FollowAllOrderByCreateAtReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Limit != 0 {
		i = encodeVarintFollow(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x18
	}
	if m.UserID != 0 {
		i = encodeVarintFollow(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x10
	}
	if m.CreateAt != 0 {
		i = encodeVarintFollow(dAtA, i, uint64(m.CreateAt))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FollowAllOrderByCreateAtResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FollowAllOrderByCreateAtResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FollowAllOrderByCreateAtResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Follows) > 0 {
		for iNdEx := len(m.Follows) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Follows[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFollow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *FollowPageRep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FollowPageRep) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FollowPageRep) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Users) > 0 {
		for iNdEx := len(m.Users) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Users[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFollow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Follows) > 0 {
		for iNdEx := len(m.Follows) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Follows[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFollow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *FansIDReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FansIDReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FansIDReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Limit != 0 {
		i = encodeVarintFollow(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x20
	}
	if m.Offset != 0 {
		i = encodeVarintFollow(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x18
	}
	if len(m.UserName) > 0 {
		i -= len(m.UserName)
		copy(dAtA[i:], m.UserName)
		i = encodeVarintFollow(dAtA, i, uint64(len(m.UserName)))
		i--
		dAtA[i] = 0x12
	}
	if m.UserID != 0 {
		i = encodeVarintFollow(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FansIDResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FansIDResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FansIDResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UID) > 0 {
		dAtA2 := make([]byte, len(m.UID)*10)
		var j1 int
		for _, num1 := range m.UID {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintFollow(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FansCountBySourceResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FansCountBySourceResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FansCountBySourceResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i = encodeVarintFollow(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FollowAllIDRep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FollowAllIDRep) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FollowAllIDRep) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Fans) > 0 {
		dAtA4 := make([]byte, len(m.Fans)*10)
		var j3 int
		for _, num1 := range m.Fans {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintFollow(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FansAllIDRep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FansAllIDRep) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FansAllIDRep) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Fans) > 0 {
		dAtA6 := make([]byte, len(m.Fans)*10)
		var j5 int
		for _, num1 := range m.Fans {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintFollow(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FollowCountReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FollowCountReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FollowCountReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserID != 0 {
		i = encodeVarintFollow(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FollowCountRep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FollowCountRep) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FollowCountRep) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i = encodeVarintFollow(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FollowPageReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FollowPageReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FollowPageReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Limit != 0 {
		i = encodeVarintFollow(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x20
	}
	if m.Offset != 0 {
		i = encodeVarintFollow(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x18
	}
	if m.CreateBy != 0 {
		i = encodeVarintFollow(dAtA, i, uint64(m.CreateBy))
		i--
		dAtA[i] = 0x10
	}
	if len(m.UserName) > 0 {
		i -= len(m.UserName)
		copy(dAtA[i:], m.UserName)
		i = encodeVarintFollow(dAtA, i, uint64(len(m.UserName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Follow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Follow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Follow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.FollowSource != 0 {
		i = encodeVarintFollow(dAtA, i, uint64(m.FollowSource))
		i--
		dAtA[i] = 0x38
	}
	if m.CreateBy != 0 {
		i = encodeVarintFollow(dAtA, i, uint64(m.CreateBy))
		i--
		dAtA[i] = 0x30
	}
	if m.CreateAt != 0 {
		i = encodeVarintFollow(dAtA, i, uint64(m.CreateAt))
		i--
		dAtA[i] = 0x28
	}
	if m.EachOther != 0 {
		i = encodeVarintFollow(dAtA, i, uint64(m.EachOther))
		i--
		dAtA[i] = 0x20
	}
	if m.FollowUID != 0 {
		i = encodeVarintFollow(dAtA, i, uint64(m.FollowUID))
		i--
		dAtA[i] = 0x18
	}
	if m.FollowID != 0 {
		i = encodeVarintFollow(dAtA, i, uint64(m.FollowID))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintFollow(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintFollow(dAtA []byte, offset int, v uint64) int {
	offset -= sovFollow(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *FollowAllOrderByCreateAtReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateAt != 0 {
		n += 1 + sovFollow(uint64(m.CreateAt))
	}
	if m.UserID != 0 {
		n += 1 + sovFollow(uint64(m.UserID))
	}
	if m.Limit != 0 {
		n += 1 + sovFollow(uint64(m.Limit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FollowAllOrderByCreateAtResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Follows) > 0 {
		for _, e := range m.Follows {
			l = e.Size()
			n += 1 + l + sovFollow(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FollowPageRep) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Follows) > 0 {
		for _, e := range m.Follows {
			l = e.Size()
			n += 1 + l + sovFollow(uint64(l))
		}
	}
	if len(m.Users) > 0 {
		for _, e := range m.Users {
			l = e.Size()
			n += 1 + l + sovFollow(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FansIDReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovFollow(uint64(m.UserID))
	}
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovFollow(uint64(l))
	}
	if m.Offset != 0 {
		n += 1 + sovFollow(uint64(m.Offset))
	}
	if m.Limit != 0 {
		n += 1 + sovFollow(uint64(m.Limit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FansIDResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.UID) > 0 {
		l = 0
		for _, e := range m.UID {
			l += sovFollow(uint64(e))
		}
		n += 1 + sovFollow(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FansCountBySourceResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Count != 0 {
		n += 1 + sovFollow(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FollowAllIDRep) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fans) > 0 {
		l = 0
		for _, e := range m.Fans {
			l += sovFollow(uint64(e))
		}
		n += 1 + sovFollow(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FansAllIDRep) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fans) > 0 {
		l = 0
		for _, e := range m.Fans {
			l += sovFollow(uint64(e))
		}
		n += 1 + sovFollow(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FollowCountReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovFollow(uint64(m.UserID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FollowCountRep) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Count != 0 {
		n += 1 + sovFollow(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FollowPageReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovFollow(uint64(l))
	}
	if m.CreateBy != 0 {
		n += 1 + sovFollow(uint64(m.CreateBy))
	}
	if m.Offset != 0 {
		n += 1 + sovFollow(uint64(m.Offset))
	}
	if m.Limit != 0 {
		n += 1 + sovFollow(uint64(m.Limit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Follow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovFollow(uint64(m.ID))
	}
	if m.FollowID != 0 {
		n += 1 + sovFollow(uint64(m.FollowID))
	}
	if m.FollowUID != 0 {
		n += 1 + sovFollow(uint64(m.FollowUID))
	}
	if m.EachOther != 0 {
		n += 1 + sovFollow(uint64(m.EachOther))
	}
	if m.CreateAt != 0 {
		n += 1 + sovFollow(uint64(m.CreateAt))
	}
	if m.CreateBy != 0 {
		n += 1 + sovFollow(uint64(m.CreateBy))
	}
	if m.FollowSource != 0 {
		n += 1 + sovFollow(uint64(m.FollowSource))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovFollow(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozFollow(x uint64) (n int) {
	return sovFollow(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *FollowAllOrderByCreateAtReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFollow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FollowAllOrderByCreateAtReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FollowAllOrderByCreateAtReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFollow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFollow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFollow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFollow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFollow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFollow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FollowAllOrderByCreateAtResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFollow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FollowAllOrderByCreateAtResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FollowAllOrderByCreateAtResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Follows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFollow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFollow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFollow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Follows = append(m.Follows, &Follow{})
			if err := m.Follows[len(m.Follows)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFollow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFollow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFollow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FollowPageRep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFollow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FollowPageRep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FollowPageRep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Follows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFollow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFollow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFollow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Follows = append(m.Follows, &Follow{})
			if err := m.Follows[len(m.Follows)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Users", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFollow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFollow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFollow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Users = append(m.Users, &imapigateway.UserInfo{})
			if err := m.Users[len(m.Users)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFollow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFollow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFollow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FansIDReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFollow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FansIDReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FansIDReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFollow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFollow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFollow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFollow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFollow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFollow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFollow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFollow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFollow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FansIDResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFollow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FansIDResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FansIDResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFollow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UID = append(m.UID, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFollow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFollow
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFollow
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UID) == 0 {
					m.UID = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFollow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UID = append(m.UID, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFollow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFollow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFollow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FansCountBySourceResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFollow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FansCountBySourceResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FansCountBySourceResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFollow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFollow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFollow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFollow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FollowAllIDRep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFollow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FollowAllIDRep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FollowAllIDRep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFollow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Fans = append(m.Fans, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFollow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFollow
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFollow
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Fans) == 0 {
					m.Fans = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFollow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Fans = append(m.Fans, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Fans", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFollow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFollow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFollow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FansAllIDRep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFollow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FansAllIDRep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FansAllIDRep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFollow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Fans = append(m.Fans, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFollow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFollow
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFollow
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Fans) == 0 {
					m.Fans = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFollow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Fans = append(m.Fans, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Fans", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFollow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFollow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFollow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FollowCountReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFollow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FollowCountReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FollowCountReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFollow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFollow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFollow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFollow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FollowCountRep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFollow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FollowCountRep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FollowCountRep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFollow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFollow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFollow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFollow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FollowPageReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFollow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FollowPageReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FollowPageReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFollow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFollow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFollow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateBy", wireType)
			}
			m.CreateBy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFollow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateBy |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFollow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFollow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFollow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFollow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFollow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Follow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFollow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Follow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Follow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFollow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FollowID", wireType)
			}
			m.FollowID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFollow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FollowID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FollowUID", wireType)
			}
			m.FollowUID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFollow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FollowUID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EachOther", wireType)
			}
			m.EachOther = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFollow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EachOther |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFollow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateBy", wireType)
			}
			m.CreateBy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFollow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateBy |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FollowSource", wireType)
			}
			m.FollowSource = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFollow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FollowSource |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFollow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFollow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFollow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFollow(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFollow
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFollow
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFollow
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFollow
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupFollow
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthFollow
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthFollow        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFollow          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupFollow = fmt.Errorf("proto: unexpected end of group")
)
