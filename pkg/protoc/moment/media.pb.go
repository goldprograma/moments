// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: media.proto

package moment

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type HighLightType int32

const (
	HighLightType_HighLightType_UNKNOWN  HighLightType = 0
	HighLightType_HighLightType_USERNAME HighLightType = 1
	HighLightType_HighLightType_URL      HighLightType = 2
)

var HighLightType_name = map[int32]string{
	0: "HighLightType_UNKNOWN",
	1: "HighLightType_USERNAME",
	2: "HighLightType_URL",
}

var HighLightType_value = map[string]int32{
	"HighLightType_UNKNOWN":  0,
	"HighLightType_USERNAME": 1,
	"HighLightType_URL":      2,
}

func (x HighLightType) String() string {
	return proto.EnumName(HighLightType_name, int32(x))
}

func (HighLightType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_07eb54b56db72a97, []int{0}
}

type HighLight struct {
	Type                 HighLightType `protobuf:"varint,1,opt,name=Type,proto3,enum=moment.HighLightType" json:"Type,omitempty"`
	Offset               int32         `protobuf:"varint,2,opt,name=Offset,proto3" json:"Offset,omitempty"`
	UserID               int32         `protobuf:"varint,3,opt,name=UserID,proto3" json:"UserID,omitempty"`
	UserName             string        `protobuf:"bytes,4,opt,name=UserName,proto3" json:"UserName,omitempty"`
	AccessHash           uint64        `protobuf:"varint,5,opt,name=AccessHash,proto3" json:"AccessHash,omitempty"`
	Limit                int32         `protobuf:"varint,6,opt,name=Limit,proto3" json:"Limit,omitempty"`
	UOffset              int32         `protobuf:"varint,7,opt,name=UOffset,proto3" json:"UOffset,omitempty"`
	ULimit               int32         `protobuf:"varint,8,opt,name=ULimit,proto3" json:"ULimit,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *HighLight) Reset()         { *m = HighLight{} }
func (m *HighLight) String() string { return proto.CompactTextString(m) }
func (*HighLight) ProtoMessage()    {}
func (*HighLight) Descriptor() ([]byte, []int) {
	return fileDescriptor_07eb54b56db72a97, []int{0}
}
func (m *HighLight) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HighLight) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HighLight.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HighLight) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HighLight.Merge(m, src)
}
func (m *HighLight) XXX_Size() int {
	return m.Size()
}
func (m *HighLight) XXX_DiscardUnknown() {
	xxx_messageInfo_HighLight.DiscardUnknown(m)
}

var xxx_messageInfo_HighLight proto.InternalMessageInfo

func (m *HighLight) GetType() HighLightType {
	if m != nil {
		return m.Type
	}
	return HighLightType_HighLightType_UNKNOWN
}

func (m *HighLight) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *HighLight) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *HighLight) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

func (m *HighLight) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *HighLight) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *HighLight) GetUOffset() int32 {
	if m != nil {
		return m.UOffset
	}
	return 0
}

func (m *HighLight) GetULimit() int32 {
	if m != nil {
		return m.ULimit
	}
	return 0
}

type MediaGetRep struct {
	Medias               []*Media `protobuf:"bytes,1,rep,name=Medias,proto3" json:"Medias,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MediaGetRep) Reset()         { *m = MediaGetRep{} }
func (m *MediaGetRep) String() string { return proto.CompactTextString(m) }
func (*MediaGetRep) ProtoMessage()    {}
func (*MediaGetRep) Descriptor() ([]byte, []int) {
	return fileDescriptor_07eb54b56db72a97, []int{1}
}
func (m *MediaGetRep) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MediaGetRep) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MediaGetRep.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MediaGetRep) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MediaGetRep.Merge(m, src)
}
func (m *MediaGetRep) XXX_Size() int {
	return m.Size()
}
func (m *MediaGetRep) XXX_DiscardUnknown() {
	xxx_messageInfo_MediaGetRep.DiscardUnknown(m)
}

var xxx_messageInfo_MediaGetRep proto.InternalMessageInfo

func (m *MediaGetRep) GetMedias() []*Media {
	if m != nil {
		return m.Medias
	}
	return nil
}

type Media struct {
	// @inject_tag: db:"id"
	ID int64 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty" db:"id"`
	// ForumID 发贴编号
	// @inject_tag: db:"main_id"
	MainID int64 `protobuf:"varint,2,opt,name=MainID,proto3" json:"MainID,omitempty" db:"main_id"`
	// Seq 图片序号
	// @inject_tag: db:"seq"
	Seq int64 `protobuf:"varint,3,opt,name=Seq,proto3" json:"Seq,omitempty" db:"seq"`
	// Name 文件名
	// @inject_tag: db:"name"
	Name string `protobuf:"bytes,4,opt,name=Name,proto3" json:"Name,omitempty" db:"name"`
	// Ext 附件类型 1=表示图片(bmp、jpg、jpeg、png) 2=视频(gif、mp4等) 3=音频 4=DOC文件pdf,txt, doc,docx, xls, ppt 等 5=压缩文件(zip,rar,tar) 6=需要获取其它数据URL 7=其它
	// @inject_tag: db:"ext"
	Ext int32 `protobuf:"varint,5,opt,name=Ext,proto3" json:"Ext,omitempty" db:"ext"`
	// Thum 缩略图信息
	// @inject_tag: db:"thum"
	Thum string `protobuf:"bytes,6,opt,name=Thum,proto3" json:"Thum,omitempty" db:"thum"`
	// Region s3 区域 以后可能需要分区域存储
	// @inject_tag: db:"region"
	Region string `protobuf:"bytes,7,opt,name=Region,proto3" json:"Region,omitempty" db:"region"`
	// Size 文件大小
	// @inject_tag: db:"size"
	Size_ int32 `protobuf:"varint,8,opt,name=Size,proto3" json:"Size,omitempty" db:"size"`
	// ThumSize 缩略图大小
	// @inject_tag: db:"thum_size"
	ThumSize int32 `protobuf:"varint,9,opt,name=ThumSize,proto3" json:"ThumSize,omitempty" db:"thum_size"`
	// Hash 换算出来的文件的hash 值
	// @inject_tag: db:"hash"
	Hash string `protobuf:"bytes,10,opt,name=Hash,proto3" json:"Hash,omitempty" db:"hash"`
	// Duration 视频文件时长
	// @inject_tag: db:"duration"
	Duration int32 `protobuf:"varint,11,opt,name=Duration,proto3" json:"Duration,omitempty" db:"duration"`
	// Height 图片尺寸
	// @inject_tag: db:"height"
	Height int32 `protobuf:"varint,12,opt,name=Height,proto3" json:"Height,omitempty" db:"height"`
	// Width 图片尺寸
	// @inject_tag: db:"width"
	Width int32 `protobuf:"varint,13,opt,name=Width,proto3" json:"Width,omitempty" db:"width"`
	// CreateTime 创建时间
	// @inject_tag: db:"create_at"
	CreateAt int64 `protobuf:"varint,14,opt,name=CreateAt,proto3" json:"CreateAt,omitempty" db:"create_at"`
	// @inject_tag: db:"status"
	Status int32 `protobuf:"varint,15,opt,name=Status,proto3" json:"Status,omitempty" db:"status"`
	// @inject_tag: db:"delete_at"
	DeleteAt             int64    `protobuf:"varint,16,opt,name=DeleteAt,proto3" json:"DeleteAt,omitempty" db:"delete_at"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Media) Reset()         { *m = Media{} }
func (m *Media) String() string { return proto.CompactTextString(m) }
func (*Media) ProtoMessage()    {}
func (*Media) Descriptor() ([]byte, []int) {
	return fileDescriptor_07eb54b56db72a97, []int{2}
}
func (m *Media) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Media) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Media.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Media) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Media.Merge(m, src)
}
func (m *Media) XXX_Size() int {
	return m.Size()
}
func (m *Media) XXX_DiscardUnknown() {
	xxx_messageInfo_Media.DiscardUnknown(m)
}

var xxx_messageInfo_Media proto.InternalMessageInfo

func (m *Media) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Media) GetMainID() int64 {
	if m != nil {
		return m.MainID
	}
	return 0
}

func (m *Media) GetSeq() int64 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *Media) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Media) GetExt() int32 {
	if m != nil {
		return m.Ext
	}
	return 0
}

func (m *Media) GetThum() string {
	if m != nil {
		return m.Thum
	}
	return ""
}

func (m *Media) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *Media) GetSize_() int32 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *Media) GetThumSize() int32 {
	if m != nil {
		return m.ThumSize
	}
	return 0
}

func (m *Media) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *Media) GetDuration() int32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *Media) GetHeight() int32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *Media) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *Media) GetCreateAt() int64 {
	if m != nil {
		return m.CreateAt
	}
	return 0
}

func (m *Media) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *Media) GetDeleteAt() int64 {
	if m != nil {
		return m.DeleteAt
	}
	return 0
}

func init() {
	proto.RegisterEnum("moment.HighLightType", HighLightType_name, HighLightType_value)
	proto.RegisterType((*HighLight)(nil), "moment.HighLight")
	proto.RegisterType((*MediaGetRep)(nil), "moment.MediaGetRep")
	proto.RegisterType((*Media)(nil), "moment.Media")
}

func init() { proto.RegisterFile("media.proto", fileDescriptor_07eb54b56db72a97) }

var fileDescriptor_07eb54b56db72a97 = []byte{
	// 504 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x5c, 0x93, 0xc1, 0x8e, 0x12, 0x41,
	0x10, 0x86, 0xb7, 0x19, 0x60, 0xa1, 0x70, 0x11, 0x5b, 0x21, 0x2d, 0x07, 0x42, 0x48, 0x4c, 0x50,
	0x13, 0x0e, 0xe8, 0xcd, 0x78, 0x60, 0x1d, 0xb2, 0x10, 0x81, 0x4d, 0x7a, 0x96, 0x6c, 0x62, 0x62,
	0xcc, 0xc8, 0xd6, 0x32, 0x9d, 0x38, 0x80, 0x33, 0x8d, 0x51, 0x9f, 0xd0, 0xa3, 0x8f, 0x60, 0x38,
	0x7a, 0xf3, 0x0d, 0x4c, 0x55, 0x0f, 0x64, 0xd9, 0x5b, 0x7d, 0x7f, 0xff, 0x5d, 0x3d, 0xf5, 0x77,
	0x0f, 0x54, 0x62, 0xbc, 0x31, 0x61, 0x6f, 0x93, 0xac, 0xed, 0x5a, 0x16, 0xe3, 0x75, 0x8c, 0x2b,
	0xdb, 0xf9, 0x2b, 0xa0, 0x3c, 0x32, 0xcb, 0x68, 0x62, 0x96, 0x91, 0x95, 0xcf, 0x21, 0x7f, 0xf5,
	0x63, 0x83, 0x4a, 0xb4, 0x45, 0xb7, 0xda, 0xaf, 0xf7, 0x9c, 0xa9, 0x77, 0x30, 0xd0, 0xa2, 0x66,
	0x8b, 0x6c, 0x40, 0xf1, 0xf2, 0xf6, 0x36, 0x45, 0xab, 0x72, 0x6d, 0xd1, 0x2d, 0xe8, 0x8c, 0x48,
	0x9f, 0xa7, 0x98, 0x8c, 0x7d, 0xe5, 0x39, 0xdd, 0x91, 0x6c, 0x42, 0x89, 0xaa, 0x59, 0x18, 0xa3,
	0xca, 0xb7, 0x45, 0xb7, 0xac, 0x0f, 0x2c, 0x5b, 0x00, 0x83, 0xc5, 0x02, 0xd3, 0x74, 0x14, 0xa6,
	0x91, 0x2a, 0xb4, 0x45, 0x37, 0xaf, 0xef, 0x28, 0xf2, 0x09, 0x14, 0x26, 0x26, 0x36, 0x56, 0x15,
	0xb9, 0xa5, 0x03, 0xa9, 0xe0, 0x74, 0x9e, 0x7d, 0xc2, 0x29, 0xeb, 0x7b, 0xe4, 0x6f, 0x70, 0x1b,
	0x4a, 0xd9, 0x37, 0x30, 0x75, 0x5e, 0x43, 0x65, 0x4a, 0x19, 0x5c, 0xa0, 0xd5, 0xb8, 0x91, 0xcf,
	0xa0, 0xc8, 0x98, 0x2a, 0xd1, 0xf6, 0xba, 0x95, 0xfe, 0xd9, 0x7e, 0x5e, 0x56, 0x75, 0xb6, 0xd8,
	0xf9, 0x97, 0x83, 0x02, 0x97, 0xb2, 0x0a, 0xb9, 0xb1, 0xcf, 0xe1, 0x78, 0x3a, 0x37, 0xf6, 0xe9,
	0x9c, 0x69, 0x68, 0x56, 0x63, 0x9f, 0x33, 0xf0, 0x74, 0x46, 0xb2, 0x06, 0x5e, 0x80, 0x5f, 0x39,
	0x00, 0x4f, 0x53, 0x29, 0x25, 0xe4, 0xef, 0x4c, 0xce, 0x35, 0xb9, 0x86, 0xdf, 0x2d, 0x8f, 0x5b,
	0xd0, 0x54, 0x92, 0xeb, 0x2a, 0xda, 0xc6, 0x3c, 0x66, 0x59, 0x73, 0x4d, 0x67, 0x68, 0x5c, 0x9a,
	0xf5, 0x8a, 0x87, 0x2c, 0xeb, 0x8c, 0xc8, 0x1b, 0x98, 0x9f, 0x98, 0x4d, 0xc8, 0x35, 0x65, 0x4c,
	0x7b, 0x58, 0x2f, 0xb3, 0x7e, 0x60, 0xf2, 0x73, 0xba, 0xe0, 0x7a, 0x73, 0xae, 0x4d, 0x28, 0xf9,
	0xdb, 0x24, 0xb4, 0xd4, 0xbd, 0xe2, 0xfc, 0x7b, 0xa6, 0x73, 0x47, 0x48, 0x77, 0xae, 0x1e, 0xb8,
	0x0c, 0x1d, 0xd1, 0x5d, 0x5c, 0x9b, 0x1b, 0x1b, 0xa9, 0x33, 0x77, 0x17, 0x0c, 0xd4, 0xe9, 0x5d,
	0x82, 0xa1, 0xc5, 0x81, 0x55, 0x55, 0x1e, 0xfb, 0xc0, 0xd4, 0x29, 0xb0, 0xa1, 0xdd, 0xa6, 0xea,
	0xa1, 0xeb, 0xe4, 0x88, 0x4f, 0xc7, 0x2f, 0xc8, 0x7b, 0x6a, 0x6e, 0xcf, 0x9e, 0x5f, 0x7c, 0x84,
	0xb3, 0xa3, 0x47, 0x27, 0x9f, 0x42, 0xfd, 0x48, 0xf8, 0x34, 0x9f, 0xbd, 0x9f, 0x5d, 0x5e, 0xcf,
	0x6a, 0x27, 0xb2, 0x09, 0x8d, 0x7b, 0x4b, 0xc1, 0x50, 0xcf, 0x06, 0xd3, 0x61, 0x4d, 0xc8, 0x3a,
	0x3c, 0xba, 0xb7, 0xa6, 0x27, 0xb5, 0x5c, 0xff, 0x2d, 0x54, 0xf9, 0x46, 0xfd, 0xf3, 0x00, 0x93,
	0x6f, 0x66, 0x81, 0xf2, 0x25, 0x78, 0x17, 0x68, 0xe5, 0xf1, 0x13, 0x68, 0x3e, 0x3e, 0x42, 0xf7,
	0x6c, 0x3a, 0x27, 0xe7, 0x8d, 0x5f, 0xbb, 0x96, 0xf8, 0xbd, 0x6b, 0x89, 0x3f, 0xbb, 0x96, 0xf8,
	0x50, 0xea, 0xbd, 0x71, 0xae, 0xcf, 0x45, 0xfe, 0xb7, 0x5e, 0xfd, 0x0f, 0x00, 0x00, 0xff, 0xff,
	0x27, 0x68, 0x7a, 0xbb, 0x6a, 0x03, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MediaDBServiceClient is the client API for MediaDBService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MediaDBServiceClient interface {
	Get(ctx context.Context, in *Media, opts ...grpc.CallOption) (*MediaGetRep, error)
}

type mediaDBServiceClient struct {
	cc *grpc.ClientConn
}

func NewMediaDBServiceClient(cc *grpc.ClientConn) MediaDBServiceClient {
	return &mediaDBServiceClient{cc}
}

func (c *mediaDBServiceClient) Get(ctx context.Context, in *Media, opts ...grpc.CallOption) (*MediaGetRep, error) {
	out := new(MediaGetRep)
	err := c.cc.Invoke(ctx, "/moment.MediaDBService/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MediaDBServiceServer is the server API for MediaDBService service.
type MediaDBServiceServer interface {
	Get(context.Context, *Media) (*MediaGetRep, error)
}

// UnimplementedMediaDBServiceServer can be embedded to have forward compatible implementations.
type UnimplementedMediaDBServiceServer struct {
}

func (*UnimplementedMediaDBServiceServer) Get(ctx context.Context, req *Media) (*MediaGetRep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}

func RegisterMediaDBServiceServer(s *grpc.Server, srv MediaDBServiceServer) {
	s.RegisterService(&_MediaDBService_serviceDesc, srv)
}

func _MediaDBService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Media)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MediaDBServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.MediaDBService/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MediaDBServiceServer).Get(ctx, req.(*Media))
	}
	return interceptor(ctx, in, info, handler)
}

var _MediaDBService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "moment.MediaDBService",
	HandlerType: (*MediaDBServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _MediaDBService_Get_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "media.proto",
}

func (m *HighLight) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HighLight) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HighLight) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ULimit != 0 {
		i = encodeVarintMedia(dAtA, i, uint64(m.ULimit))
		i--
		dAtA[i] = 0x40
	}
	if m.UOffset != 0 {
		i = encodeVarintMedia(dAtA, i, uint64(m.UOffset))
		i--
		dAtA[i] = 0x38
	}
	if m.Limit != 0 {
		i = encodeVarintMedia(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x30
	}
	if m.AccessHash != 0 {
		i = encodeVarintMedia(dAtA, i, uint64(m.AccessHash))
		i--
		dAtA[i] = 0x28
	}
	if len(m.UserName) > 0 {
		i -= len(m.UserName)
		copy(dAtA[i:], m.UserName)
		i = encodeVarintMedia(dAtA, i, uint64(len(m.UserName)))
		i--
		dAtA[i] = 0x22
	}
	if m.UserID != 0 {
		i = encodeVarintMedia(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x18
	}
	if m.Offset != 0 {
		i = encodeVarintMedia(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintMedia(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MediaGetRep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MediaGetRep) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MediaGetRep) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Medias) > 0 {
		for iNdEx := len(m.Medias) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Medias[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMedia(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Media) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Media) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Media) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DeleteAt != 0 {
		i = encodeVarintMedia(dAtA, i, uint64(m.DeleteAt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.Status != 0 {
		i = encodeVarintMedia(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x78
	}
	if m.CreateAt != 0 {
		i = encodeVarintMedia(dAtA, i, uint64(m.CreateAt))
		i--
		dAtA[i] = 0x70
	}
	if m.Width != 0 {
		i = encodeVarintMedia(dAtA, i, uint64(m.Width))
		i--
		dAtA[i] = 0x68
	}
	if m.Height != 0 {
		i = encodeVarintMedia(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x60
	}
	if m.Duration != 0 {
		i = encodeVarintMedia(dAtA, i, uint64(m.Duration))
		i--
		dAtA[i] = 0x58
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintMedia(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x52
	}
	if m.ThumSize != 0 {
		i = encodeVarintMedia(dAtA, i, uint64(m.ThumSize))
		i--
		dAtA[i] = 0x48
	}
	if m.Size_ != 0 {
		i = encodeVarintMedia(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Region) > 0 {
		i -= len(m.Region)
		copy(dAtA[i:], m.Region)
		i = encodeVarintMedia(dAtA, i, uint64(len(m.Region)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Thum) > 0 {
		i -= len(m.Thum)
		copy(dAtA[i:], m.Thum)
		i = encodeVarintMedia(dAtA, i, uint64(len(m.Thum)))
		i--
		dAtA[i] = 0x32
	}
	if m.Ext != 0 {
		i = encodeVarintMedia(dAtA, i, uint64(m.Ext))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMedia(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if m.Seq != 0 {
		i = encodeVarintMedia(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x18
	}
	if m.MainID != 0 {
		i = encodeVarintMedia(dAtA, i, uint64(m.MainID))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintMedia(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintMedia(dAtA []byte, offset int, v uint64) int {
	offset -= sovMedia(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *HighLight) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovMedia(uint64(m.Type))
	}
	if m.Offset != 0 {
		n += 1 + sovMedia(uint64(m.Offset))
	}
	if m.UserID != 0 {
		n += 1 + sovMedia(uint64(m.UserID))
	}
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovMedia(uint64(l))
	}
	if m.AccessHash != 0 {
		n += 1 + sovMedia(uint64(m.AccessHash))
	}
	if m.Limit != 0 {
		n += 1 + sovMedia(uint64(m.Limit))
	}
	if m.UOffset != 0 {
		n += 1 + sovMedia(uint64(m.UOffset))
	}
	if m.ULimit != 0 {
		n += 1 + sovMedia(uint64(m.ULimit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MediaGetRep) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Medias) > 0 {
		for _, e := range m.Medias {
			l = e.Size()
			n += 1 + l + sovMedia(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Media) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMedia(uint64(m.ID))
	}
	if m.MainID != 0 {
		n += 1 + sovMedia(uint64(m.MainID))
	}
	if m.Seq != 0 {
		n += 1 + sovMedia(uint64(m.Seq))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMedia(uint64(l))
	}
	if m.Ext != 0 {
		n += 1 + sovMedia(uint64(m.Ext))
	}
	l = len(m.Thum)
	if l > 0 {
		n += 1 + l + sovMedia(uint64(l))
	}
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovMedia(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovMedia(uint64(m.Size_))
	}
	if m.ThumSize != 0 {
		n += 1 + sovMedia(uint64(m.ThumSize))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovMedia(uint64(l))
	}
	if m.Duration != 0 {
		n += 1 + sovMedia(uint64(m.Duration))
	}
	if m.Height != 0 {
		n += 1 + sovMedia(uint64(m.Height))
	}
	if m.Width != 0 {
		n += 1 + sovMedia(uint64(m.Width))
	}
	if m.CreateAt != 0 {
		n += 1 + sovMedia(uint64(m.CreateAt))
	}
	if m.Status != 0 {
		n += 1 + sovMedia(uint64(m.Status))
	}
	if m.DeleteAt != 0 {
		n += 2 + sovMedia(uint64(m.DeleteAt))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovMedia(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMedia(x uint64) (n int) {
	return sovMedia(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *HighLight) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMedia
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HighLight: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HighLight: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMedia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= HighLightType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMedia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMedia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMedia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMedia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMedia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMedia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMedia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UOffset", wireType)
			}
			m.UOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMedia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UOffset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ULimit", wireType)
			}
			m.ULimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMedia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ULimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMedia(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMedia
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMedia
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MediaGetRep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMedia
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MediaGetRep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MediaGetRep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Medias", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMedia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMedia
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMedia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Medias = append(m.Medias, &Media{})
			if err := m.Medias[len(m.Medias)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMedia(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMedia
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMedia
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Media) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMedia
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Media: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Media: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMedia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MainID", wireType)
			}
			m.MainID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMedia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MainID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMedia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMedia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMedia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMedia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ext", wireType)
			}
			m.Ext = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMedia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ext |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMedia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMedia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMedia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Thum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMedia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMedia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMedia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMedia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThumSize", wireType)
			}
			m.ThumSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMedia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ThumSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMedia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMedia
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMedia
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMedia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMedia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMedia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMedia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMedia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteAt", wireType)
			}
			m.DeleteAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMedia
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeleteAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMedia(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMedia
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMedia
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMedia(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMedia
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMedia
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMedia
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMedia
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMedia
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMedia
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMedia        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMedia          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMedia = fmt.Errorf("proto: unexpected end of group")
)
